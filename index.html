<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard Backlog Incidentes TI</title>
  <!-- jsPDF (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <!-- jsPDF-AutoTable (debe ir DESPU√âS de jsPDF) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.js"></script>

  <!-- Chart.js + DataLabels -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

</head>

<style>
  :root {
    /* Paleta y acentos */
    --bg: #0f172a;
    --card: #111827;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #4cc9f0;
    --accent2: #219ebc;

    /* Alturas por tipo de secci√≥n (ajustables) */
    --height-kpi: 360px;
    --height-chart: 320px;
    --height-table: 520px;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: linear-gradient(180deg, #0b1220, #0f172a);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans';
  }

  .topbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 16px 20px;
    border-bottom: 1px solid #1f2937;
    backdrop-filter: blur(6px);
  }

  .topbar h1 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .actions {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .button {
    background: var(--accent);
    color: #0b1220;
    border: none;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .button:hover {
    background: var(--accent2);
    transform: translateY(-1px);
  }

  .button.secondary {
    background: #334155;
    color: var(--text);
  }

  .button.secondary:hover {
    background: #475569;
  }

  .muted {
    color: var(--muted);
    font-size: .9rem;
  }

  /* Banner de estado del archivo */
  .status-banner {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: #1e293b;
    border-bottom: 1px solid #334155;
    font-size: 0.85rem;
    color: var(--muted);
  }

  .status-banner .pill {
    background: #334155;
    color: var(--text);
    padding: 3px 10px;
    border-radius: 12px;
    font-weight: 500;
    font-size: 0.8rem;
  }

  /* Contenedor principal */
  .page {
    padding: 16px;
    grid-template-columns: 1fr;
    gap: 16px;
  }

  /* Contenedor de gr√°ficas */
  .charts-grid {
    display: grid;
    grid-template-columns: 1fr;
    width: 100%;
    gap: 32px;
    /* üëà separaci√≥n real entre gr√°ficas */
  }

  .card {
    background: var(--card);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    min-height: var(--height-chart);
  }

  .card h2 {
    margin: 0 0 8px 0;
    font-size: 1rem;
  }

  /* KPI ocupa su altura configurada */
  .card.kpi {
    min-height: var(--height-kpi);
  }

  .canvas-wrap {
    position: relative;
    flex: 1 1 auto;
  }

  .canvas-wrap canvas {
    position: absolute;
    inset: 0;
    width: 100% !important;
    height: 100% !important;
    display: block;
  }

  /* Tabla ancho completo debajo de las gr√°ficas */
  .card.wide {
    min-height: var(--height-table);
  }

  /* Tabla profesional */
  .table-responsive {
    width: 100%;
    overflow-x: auto;
    border-radius: 8px;
    border: 1px solid #334155;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  thead th {
    background: #1f2937;
    color: #f1f5f9;
    font-weight: 600;
    padding: 10px;
    text-align: left;
    position: sticky;
    top: 0;
    z-index: 2;
  }

  tbody tr:nth-child(even) {
    background: #0f172a;
  }

  tbody tr:nth-child(odd) {
    background: #111827;
  }

  tbody td {
    padding: 8px;
    color: #e5e7eb;
    border-bottom: 1px solid #334155;
    white-space: nowrap;
  }

  tbody tr:hover {
    background: #1e293b;
  }

  footer {
    padding: 20px;
    text-align: center;
    color: var(--muted);
  }

  /* Responsive */
  @media (max-width: 1200px) {
    .charts-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 760px) {
    .charts-grid {
      grid-template-columns: 1fr;
    }

    .topbar {
      flex-direction: column;
      align-items: flex-start;
    }

    .actions {
      width: 100%;
      justify-content: space-between;
    }
  }

  @media print {

    .topbar,
    .button,
    .status-banner {
      display: none !important;
    }

    body {
      background: white;
      color: black;
    }

    .card {
      border: none;
    }

    .card.kpi {
      min-height: 260px;
    }

    .card {
      min-height: 220px;
    }

    .card.wide {
      min-height: auto;
    }

    .canvas-wrap canvas {
      height: 100% !important;
    }
  }

  /* === ESTILOS GITHUB SYNC === */

  /* Panel de admin - oculto por defecto */
  .github-config-panel {
    display: none;
  }
  .github-config-panel.admin-mode {
    display: block;
  }

  .github-config-panel {
    background: linear-gradient(135deg, #e6e6fa 0%, #f0e6ff 100%);
    border: 2px solid #9370db;
    border-radius: 12px;
    padding: 25px;
    margin: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  .github-config-panel h2 {
    font-size: 20px;
    color: #333;
    margin: 0 0 15px 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .github-config-panel h2::before {
    content: "üîó";
  }
  .github-status {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: #90ee90;
    color: #2d5016;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 500;
  }
  .github-status::before {
    content: "‚úì";
  }
  .github-form {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin-top: 15px;
  }
  .form-group {
    display: flex;
    flex-direction: column;
  }
  .form-group label {
    font-size: 13px;
    font-weight: 600;
    color: #555;
    margin-bottom: 5px;
  }
  .form-group input {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 14px;
    font-family: "Courier New", monospace;
  }
  .form-group input:focus {
    outline: none;
    border-color: #9370db;
    box-shadow: 0 0 0 3px rgba(147, 112, 219, 0.1);
  }
  .form-group input[type="password"] {
    letter-spacing: 3px;
  }
  .github-actions {
    grid-column: 1 / -1;
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }
  .github-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  .github-btn-primary {
    background: #5b9bd5;
    color: white;
  }
  .github-btn-primary:hover {
    background: #4a8ac4;
    transform: translateY(-2px);
  }
  .github-info {
    grid-column: 1 / -1;
    margin-top: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 8px;
    font-size: 13px;
    color: #666;
  }
  .github-info-item {
    display: flex;
    align-items: center;
    gap: 5px;
    margin: 5px 0;
  }
  .github-info-item::before {
    content: "üí°";
  }
  .info-highlight {
    color: #9370db;
    font-weight: 600;
  }
  .auto-load-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background: #4caf50;
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    display: none;
    align-items: center;
    gap: 10px;
    z-index: 1000;
  }
  .auto-load-indicator.show {
    display: flex;
  }
  .loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  @media (max-width: 1024px) {
    .github-form {
      grid-template-columns: 1fr;
    }
  }

</style>

<body>
  <header class="topbar">
    <a href="index.html"> <!-- Enlace a la p√°gina principal -->
      <img src="LOGO.png" alt="Logo de Banco Uni√≥n S.A" width="150" height="50">
    </a>
    <h1>üìä Dashboard Backlog Incidentes TI - Gesti√≥n de Incidentes Nivel 2</h1>
    <div class="actions">
      <label for="csvFile" class="button">üìÇ Cargar CSV Local</label>
      <input id="csvFile" type="file" accept=".csv" style="display:none" />
      <button id="btnUploadToGithub" class="button" style="display:none; background: #28a745;">‚òÅÔ∏è Subir a GitHub</button>
      <button id="btnPdfReport" class="button">üìä Reporte PDF Ejecutivo</button>
      <button id="btnExcelReport" class="button">üìó Exportar Excel</button>
      <button id="btnClear" class="button secondary">üßπ Limpiar cach√©</button>
      <span id="lastUpdate" class="muted">√öltima actualizaci√≥n: ‚Äî</span>
    </div>
  </header>

  <!-- Indicador de carga autom√°tica -->
  <div id="autoLoadIndicator" class="auto-load-indicator">
    <div class="loading-spinner"></div>
    <span id="autoLoadMessage">Cargando datos desde GitHub...</span>
  </div>

  <!-- Panel de Configuraci√≥n GitHub -->
  <div class="github-config-panel">
    <h2>
      Sincronizaci√≥n Multi-Dispositivo con GitHub
      <span class="github-status" id="githubStatus" style="display:none;"></span>
    </h2>
    <div class="github-form">
      <div class="form-group">
        <label for="githubUser">Usuario de GitHub:</label>
        <input type="text" id="githubUser" placeholder="johnja1989" value="johnja1989">
      </div>
      <div class="form-group">
        <label for="githubRepo">Repositorio:</label>
        <input type="text" id="githubRepo" placeholder="Repositorio" value="dashboard_incidentes_ti_nivel2_Banco_Union_S.A">
      </div>
      <div class="form-group">
        <label for="githubBranch">Rama (branch):</label>
        <input type="text" id="githubBranch" placeholder="main" value="main">
      </div>
      <div class="form-group">
        <label for="githubToken">Token Personal (PAT):</label>
        <input type="password" id="githubToken" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
      </div>
      <div class="github-actions">
        <button class="github-btn github-btn-primary" id="btnTestConnection">üîç Probar Conexi√≥n</button>
        <button class="github-btn github-btn-primary" id="btnSaveConfig">üíæ Guardar Configuraci√≥n</button>
        <button class="github-btn github-btn-primary" id="btnCopyUrls" style="background: #6c757d;">
          üìã Copiar URLs
        </button>
      </div>
      <div class="github-info">
        <div class="github-info-item"><strong>Admin:</strong> Solo el administrador configura token.</div>
        <div class="github-info-item">Todos los usuarios leer√°n datos desde GitHub autom√°ticamente.</div>
        <div class="github-info-item">1) Crea un <span class="info-highlight">Personal Access Token</span> con permisos <span class="info-highlight">repo</span></div>
        <div class="github-info-item">2) Completa usuario/repo/branch/token</div>
        <div class="github-info-item">3) Guarda configuraci√≥n</div>
        <div class="github-info-item">4) Carga CSV localmente y conf√≠rma subirlo a GitHub</div>
        <div class="github-info-item">5) Los usuarios se actualizan autom√°ticamente</div>
      </div>
    </div>
  </div>


  <!-- Banner de estado -->
  <div class="status-banner">
    <span>üìÑ Archivo:</span>
    <span id="bannerFile" class="pill">‚Äî</span>
    <span>‚è∞ Guardado:</span>
    <span id="bannerSaved" class="pill">‚Äî</span>
    <span>üîó Fuente:</span>
    <span id="bannerSource" class="pill">Local</span>
  </div>

  <main class="page">
    <!-- GR√ÅFICAS: 3 filas √ó 2 columnas -->
    <div class="charts-grid">
      <!-- Fila 1 -->
      <section class="card kpi">
        <h2>Incidentes Reportados</h2>
        <div class="canvas-wrap">
          <canvas id="chartIncidentes"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>Abiertos VS Cerrados</h2>
        <div class="canvas-wrap">
          <canvas id="chartEstado"></canvas>
        </div>
      </section>

      <!-- Fila 2 -->
      <section class="card">
        <h2>Tiempo Tickets (Promedio)</h2>
        <div class="canvas-wrap">
          <canvas id="chartTiempo"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>Responsables</h2>
        <div class="canvas-wrap">
          <canvas id="chartResponsables"></canvas>
        </div>
      </section>

      <!-- Fila 3 -->
      <section class="card">
        <h2>Tipificaci√≥n por Servicio</h2>
        <div class="canvas-wrap">
          <canvas id="chartServicio"></canvas>
        </div>
      </section>

      <section class="card">
        <h2>Proveedores</h2>
        <div class="canvas-wrap">
          <canvas id="chartProveedor"></canvas>
        </div>
      </section>

      <!-- Fila 4 -->
      <section class="card">
        <h2>Categor√≠a ‚Äî Abiertos vs Cerrados</h2>
        <div class="canvas-wrap">
          <canvas id="chartCategoria"></canvas>
        </div>
      </section>

    </div>

    <!-- Tabla Datos Detallados -->
    <section class="card wide">
      <h2>Datos Detallados</h2>
      <div class="table-responsive">
        <table id="tablaDatos">
          <thead>
            <tr><!-- Se llena din√°micamente seg√∫n el CSV --></tr>
          </thead>
          <tbody>
            <tr>
              <td colspan="100" class="muted">Cargando datos...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <footer class="footer">
    Creado por: John Jairo Vargas Gonz√°lez - Ingeniero de Soluciones TI - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9df7f2f5f3b3ebfceffafceeddfffcf3fef2e8f3f4f2f3b3fef2f0">[email&#160;protected]</a><br />
    <span class="muted">"Transformando ideas en soluciones tecnol√≥gicas"</span>
  </footer>

  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>

    // ==========================================
    // DETECCI√ìN DE MODO ADMINISTRADOR
    // ==========================================
    
    function isAdminMode() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('admin') === '1';
    }
    
    function showAdminPanel() {
      const panel = document.querySelector('.github-config-panel');
      if (panel && isAdminMode()) {
        panel.classList.add('admin-mode');
        console.log('üë§ Modo Administrador activado');
      } else {
        console.log('üë• Modo Usuario normal');
      }
    }
    
    // Ejecutar inmediatamente
    showAdminPanel();
    
    /** 
 * Dashboard Incidentes TI ‚Äî Banco Uni√≥n
 * - CSV -> Visualizaciones (Chart.js + DataLabels)
 * - PDF Ejecutivo (jsPDF + AutoTable) con encabezado corporativo y logo
 * - Excel (SheetJS)
 * - Persistencia localStorage del estado
 * - Camino A: Narrativa ejecutiva sin LLM (reglas / umbrales)
 * - Camino B: Narrativa con LLM local (Ollama o LM Studio), fallback autom√°tico
 */

    // ==========================================================
    // ‚úÖ CONFIG P√öBLICA (EDITAR AQU√ç) - todos leen desde GitHub
    // ==========================================================
    const GITHUB_PUBLIC_READ = {
      user: "johnja1989",   // üëà CAMBIA ESTO
      repo: "dashboard_incidentes_ti_nivel2_Banco_Union_S.A",      // üëà CAMBIA ESTO
      branch: "main"               // üëà main o gh-pages
    };

    /* ===================== Constantes de PDF (Landscape forzado) ===================== */
    const PAGE_ORIENTATION = 'landscape';  // ‚Üê Siempre horizontal
    const PAGE_UNIT = 'pt';
    const PAGE_FORMAT = 'a4';

    /* Helper para a√±adir p√°ginas en horizontal de forma consistente */
    function addLandscapePage(doc) {
      doc.addPage(PAGE_ORIENTATION, PAGE_UNIT);
    }

    /* ===================== Configuraci√≥n del LLM local (Camino B) ===================== */
    /**
     * Cambia estas constantes seg√∫n tu entorno:
     * - LLM_PROVIDER: 'ollama' | 'lmstudio'
     * - Para Ollama: usa http://localhost:11434/api/generate (no-stream)
     * - Para LM Studio: usa http://localhost:1234/v1/chat/completions (OpenAI compatible)
     */
    const LLM_ENABLED = true;                 // Activa/desactiva la narrativa LLM
    const LLM_PROVIDER = 'ollama';            // 'ollama' o 'lmstudio'
    const LLM_OLLAMA_MODEL = 'llama3.2';      // Modelo local (aj√∫stalo a tu preferido)
    const LLM_OLLAMA_URL = 'http://localhost:11434/api/generate';
    const LLM_LMSTUDIO_URL = 'http://localhost:1234/v1/chat/completions';
    const LLM_TIMEOUT_MS = 9000;            // Timeout razonable para respuesta local

    /* ===================== Utils ===================== */
    function norm(s) {
      s = (s === undefined || s === null) ? '' : String(s);
      return s.trim()
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9_ ]/g, '')
        .replace(/\s+/g, ' ');
    }
    function parseNumber(val) {
      if (val === undefined || val === null) return NaN;
      const s = String(val).replace(',', '.');
      const m = s.match(/-?\d+(\.\d+)?/);
      return m ? parseFloat(m[0]) : NaN;
    }
    function cleanText(value) {
      if (value === undefined || value === null) return '';
      let text = String(value).trim();
      text = text.replace(/\s+/g, ' ').replace(/\u00A0/g, ' ').replace(/\uFFFD/g, '').replace(/\ufffd/g, '');
      text = text.replace(/[\u{1F300}-\u{1FAFF}]/gu, ''); // quitar emojis 
      return text.trim();
    }
    function isDateVal(v) {
      const s = String(v === undefined || v === null ? '' : v).trim();
      if (!s) return false;
      const iso = /^\d{4}\-\d{1,2}\-\d{1,2}/.test(s);
      const latam = /^\d{1,2}[\/.\-]\d{1,2}[\/.\-]\d{2,4}$/.test(s);
      const dt = new Date(s);
      return iso || latam || !isNaN(dt);
    }
    function isNumVal(v) { return !isNaN(parseNumber(v)); }
    function detectType(values) {
      const sample = values.slice(0, 200);
      const dateCount = sample.filter(isDateVal).length;
      const numCount = sample.filter(isNumVal).length;
      const distinct = new Set(sample.map(function (x) { return String(x); })).size;
      if (dateCount > sample.length * 0.5) return 'date';
      if (numCount > sample.length * 0.6) return 'number';
      if (distinct <= sample.length * 0.7) return 'category';
      return 'text';
    }

    /* ===================== Sem√°ntica y schema ===================== */
    const semanticHints = {
      estado: ['estado', 'status', 'estado final', 'estado incidente', 'estado linea', 'estado proveedor'],
      responsable: ['responsable', 'asignado', 'ingeniero asignado', 'owner', 'persona', 'responsable escalamiento'],
      servicio: ['servicio', 'service', 'tipificacion', 'categoria', 'tipo', 'producto', 'componente'],
      proveedor: ['proveedor', 'vendor', 'proveedor a escalar'],
      tiempo: ['tiempo', 'duracion', 'duration', 'dias', 'edad incidente', 'edad'],
      fecha: ['fecha', 'date', 'fch', 'radicado', 'cierre', 'actualizacion', 'produccion'],
      rangoEdad: ['rango edad', 'rango_edad', 'age range', 'rango']
    };
    function inferSchema(headers, rows) {
      const schema = { roles: {}, types: {} };
      headers.forEach(function (h) {
        const vals = rows.map(function (r) { return r[h]; }).filter(function (v) { return v !== undefined; });
        schema.types[h] = detectType(vals);
        const nh = norm(h);
        Object.keys(semanticHints).forEach(function (role) {
          const list = semanticHints[role];
          for (var i = 0; i < list.length; i++) {
            if (nh.indexOf(norm(list[i])) >= 0) { schema.roles[role] = h; break; }
          }
        });
      });
      // Tiempo: fallback al campo num√©rico con m√°s hits 
      if (!schema.roles.tiempo) {
        var best = null, bestHits = -1;
        headers.forEach(function (h) {
          if (schema.types[h] !== 'number' && schema.types[h] !== 'text') return;
          const hits = rows.map(function (r) { return parseNumber(r[h]); })
            .filter(function (n) { return !isNaN(n); })
            .length;
          if (hits > bestHits) { bestHits = hits; best = h; }
        });
        if (best) schema.roles.tiempo = best;
      }
      // Estado: categor√≠a con 2..15 valores 
      if (!schema.roles.estado) {
        const cats = headers.filter(function (h) { return schema.types[h] === 'category' || schema.types[h] === 'text'; });
        var best = null, uniqBest = 9999;
        cats.forEach(function (h) {
          const uniq = new Set(rows.map(function (r) { return r[h]; })).size;
          if (uniq >= 2 && uniq <= 15 && uniq < uniqBest) { uniqBest = uniq; best = h; }
        });
        if (best) schema.roles.estado = best;
      }
      // Responsable 
      if (!schema.roles.responsable) {
        const nonNums = headers.filter(function (h) { return schema.types[h] !== 'number'; });
        var best = null, score = 0;
        nonNums.forEach(function (h) {
          const vals = rows.map(function (r) { return String(r[h] === undefined ? '' : r[h]); }).slice(0, 200);
          const hit = vals.filter(function (v) { return /[A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]+\s+[A-Za-z√Å√â√ç√ì√ö√ë√°√©√≠√≥√∫√±]/.test(v); }).length;
          if (hit > score) { score = hit; best = h; }
        });
        if (best) schema.roles.responsable = best;
      }
      // Servicio 
      if (!schema.roles.servicio) {
        const cats = headers.filter(function (h) { return schema.types[h] === 'category' || schema.types[h] === 'text'; });
        var best = null, uniqBest = 0;
        cats.forEach(function (h) {
          const uniq = new Set(rows.map(function (r) { return r[h]; })).size;
          if (uniq > uniqBest) { uniqBest = uniq; best = h; }
        });
        if (best) schema.roles.servicio = best;
      }
      // Proveedor (regex) 
      if (!schema.roles.proveedor) {
        const prov = headers.find(function (h) { return /(proveedor|vendor)/i.test(h); });
        if (prov) schema.roles.proveedor = prov;
      }
      // Fecha 
      if (!schema.roles.fecha) {
        const d = headers.find(function (h) { return schema.types[h] === 'date'; });
        if (d) schema.roles.fecha = d;
      }
      return schema;
    }

    /* ===================== Agregaciones ===================== */
    function countBy(arr, keyCol) {
      const m = new Map();
      arr.forEach(function (r) {
        const k = r[keyCol];
        m.set(k, (m.get(k) || 0) + 1);
      });
      return Array.from(m.entries()).map(function (pair) {
        return { label: pair[0], value: pair[1] };
      }).sort(function (a, b) {
        return String(a.label).localeCompare(String(b.label));
      });
    }
    function average(arr) { return !arr.length ? 0 : arr.reduce(function (a, b) { return a + b; }, 0) / arr.length; }

    /* ===================== Orden l√≥gico de rangos ===================== */
    function getRangeWeight(labelRaw) {
      const label = norm(labelRaw);
      var m = label.match(/(>\s*\+)\s*(\d+)/);
      if (m) return Number(m[2]) + 0.1;
      m = label.match(/(\d+)\s*-\s*(\d+)/);
      if (m) return Number(m[2]);
      m = label.match(/<\s*(\d+)/);
      if (m) return Number(m[1]) - 0.1;
      m = label.match(/(\d+)/);
      if (m) return Number(m[1]);
      return 9999;
    }

    /* ===================== Estado global y persistencia ===================== */
    var rawData = [];
    var charts = {};
    var schema = null;
    const STORAGE_KEY = 'dashboard_incidentes_state_v1';
    function saveState() {
      try {
        const payload = {
          rawData: rawData,
          schema: schema,
          meta: { fileName: (window.__lastCsvName || 'CSV'), savedAt: new Date().toISOString() }
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        updateBanner(payload.meta.fileName, new Date(payload.meta.savedAt));
      } catch (err) { console.error('Error guardando estado:', err); }
    }
    function loadState() {
      try {
        const txt = localStorage.getItem(STORAGE_KEY);
        if (!txt) return false;
        const payload = JSON.parse(txt);
        if (!payload || !Array.isArray(payload.rawData) || !payload.rawData.length) return false;
        rawData = payload.rawData;
        schema = payload.schema || null;
        renderAll();
        const dt = payload.meta && payload.meta.savedAt ? new Date(payload.meta.savedAt) : null;
        if (dt) {
          const lastUpdate = document.getElementById('lastUpdate');
          if (lastUpdate) lastUpdate.textContent = '√öltima actualizaci√≥n: ' + dt.toLocaleString('es-CO');
          updateBanner(payload.meta.fileName || 'CSV', dt);
        }
        return true;
      } catch (err) { console.error('Error cargando estado:', err); return false; }
    }
    function clearState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        updateBanner('‚Äî', null);
        alert('Se limpi√≥ la cach√© del dashboard. Recarga la p√°gina y vuelve a cargar el CSV.');
      } catch (err) { console.error('Error limpiando estado:', err); }
    }
    function updateBanner(fileName, savedDate) {
      const f = document.getElementById('bannerFile');
      const s = document.getElementById('bannerSaved');
      if (f) f.textContent = cleanText(fileName || '‚Äî');
      if (s) s.textContent = savedDate ? savedDate.toLocaleString('es-CO') : '‚Äî';
    }

    /* ===================== Inicializaci√≥n ===================== */
    document.addEventListener('DOMContentLoaded', function () {
      const fileInput = document.getElementById('csvFile');
      const btnPdfReport = document.getElementById('btnPdfReport');
      const btnExcelReport = document.getElementById('btnExcelReport');
      const btnClear = document.getElementById('btnClear');
      loadState();
      if (fileInput) {
        fileInput.addEventListener('change', async function (e) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          window.__lastCsvName = file.name;
          const buffer = await file.arrayBuffer();
          var csvText;
          try { csvText = new TextDecoder('windows-1252').decode(buffer); }
          catch (err) { csvText = new TextDecoder('utf-8').decode(buffer); }
          Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
              rawData = (results.data || []).filter(function (row) {
                return Object.values(row).some(function (val) {
                  return val !== null && val !== undefined && String(val).trim() !== '';
                });
              });
              if (!rawData.length) { alert('El archivo CSV no contiene datos v√°lidos.'); return; }
              const headers = results.meta && results.meta.fields ? results.meta.fields : Object.keys(rawData[0] || {});
              schema = inferSchema(headers, rawData);
              renderAll();
              const lastUpdate = document.getElementById('lastUpdate');
              if (lastUpdate) lastUpdate.textContent = '√öltima actualizaci√≥n: ' + new Date().toLocaleString('es-CO');
              saveState();
            },
            error: function (err) { console.error('Error parseando CSV:', err); alert('Error al procesar el archivo CSV.'); }
          });
        });
      }
      if (btnPdfReport) {
        // generatePDFReport es async por la llamada LLM
        btnPdfReport.addEventListener('click', async function (e) {
          e.preventDefault();
          try { await generatePDFReport(); }
          catch (err) { console.error('Error generando PDF:', err); alert('Ocurri√≥ un error al generar el PDF.'); }
        });
      }
      if (btnExcelReport) {
        btnExcelReport.addEventListener('click', generateExcelReport);
      }
      if (btnClear) {
        btnClear.addEventListener('click', clearState);
      }
    });
    function renderAll() { renderTable(); renderChartsAdaptive(); }

    /* ===================== Tabla ===================== */
    function renderTable() {
      const tbody = document.querySelector('#tablaDatos tbody');
      const theadRow = document.querySelector('#tablaDatos thead tr');
      if (!tbody || !theadRow) return;
      tbody.innerHTML = '';
      if (!rawData.length) {
        tbody.innerHTML = '<tr><td colspan="5" class="muted">Sin datos para mostrar.</td></tr>';
        return;
      }
      const cols = Object.keys(rawData[0]);
      theadRow.innerHTML = cols.map(function (c) { return '<th>' + cleanText(c) + '</th>'; }).join('');
      rawData.forEach(function (r) {
        const tr = document.createElement('tr');
        tr.innerHTML = cols.map(function (c) { return '<td>' + cleanText(r[c]) + '</td>'; }).join('');
        tbody.appendChild(tr);
      });
    }

    /* ===================== Gr√°ficos ===================== */
    function destroyChart(id) { if (charts[id]) { charts[id].destroy(); charts[id] = null; } }
    function showPlaceholder(id) {
      const ctx = document.getElementById(id); if (!ctx) return;
      destroyChart(id);
      charts[id] = new Chart(ctx, {
        type: 'bar',
        data: { labels: ['Sin datos'], datasets: [{ label: '‚Äî', data: [0], backgroundColor: '#273043' }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { enabled: false } }, scales: { y: { display: false } } }
      });
    }

    /* ---- KPI: texto centrado ---- */
    const CenterTextPlugin = {
      id: 'centerText',
      afterDraw: function (chart) {
        const meta = chart.getDatasetMeta(0);
        if (!meta || !meta.data || !meta.data[0]) return;
        const ctx = chart.ctx;
        const cx = meta.data[0].x;
        const cy = meta.data[0].y;
        const opts = chart.options && chart.options.plugins && chart.options.plugins.centerText ? chart.options.plugins.centerText : {};
        const title = String(opts.title || '');
        const value = String(opts.value || '');
        const titleSize = Number(opts.titleSize || 14);
        const valueSize = Number(opts.valueSize || 28);
        const color = opts.color || '#ffffff';
        const fontFamily = 'system-ui,Segoe UI,Roboto,Arial';
        const gap = Number(opts.gap || 8);
        ctx.save();
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (title) {
          ctx.font = titleSize + 'px ' + fontFamily;
          const titleY = cy - (value ? (valueSize / 2 + gap) : 0);
          ctx.fillText(title, cx, titleY);
        }
        if (value) {
          ctx.font = 'bold ' + valueSize + 'px ' + fontFamily;
          const valueY = title ? (cy + (titleSize / 2 + gap)) : cy;
          ctx.fillText(value, cx, valueY);
        }
        ctx.restore();
      }
    };

    /* ---- Barras simples ---- */
    function buildBar(id, data, label) {
      const ctx = document.getElementById(id); if (!ctx) return; destroyChart(id);
      data.sort(function (a, b) { return b.value - a.value; });
      const SimpleValueLabels = {
        id: 'simpleValueLabels',
        afterDatasetsDraw: function (chart) {
          const ctx = chart.ctx;
          const dataset = chart.data.datasets[0];
          const meta = chart.getDatasetMeta(0);
          if (!meta || !meta.data) return;
          ctx.save();
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.font = 'bold 12px system-ui,Segoe UI,Roboto,Arial';
          meta.data.forEach(function (bar, i) {
            const v = dataset.data[i];
            if (v === null || v === undefined || isNaN(v)) return;
            const x = bar.x; const y = bar.y - 6;
            ctx.fillText(String(Math.round(Number(v))), x, y);
          });
          ctx.restore();
        }
      };
      const useDatalabels = (typeof ChartDataLabels !== 'undefined');
      charts[id] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: data.map(function (d) { return cleanText(String(d.label)); }),
          datasets: [{ label: cleanText(label), data: data.map(function (d) { return d.value; }), backgroundColor: '#90cdf4', borderColor: '#3182ce', borderWidth: 1 }]
        },
        options: {
          responsive: true, maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#ffffff', font: { size: 14, weight: 'bold' } } },
            tooltip: {
              enabled: true, titleColor: '#ffffff', bodyColor: '#ffffff',
              callbacks: { label: function (ctx) { return ctx.dataset.label + ': ' + Math.round(Number(ctx.raw)); } }
            },
            datalabels: useDatalabels ? {
              color: '#ffffff', anchor: 'end', align: 'end', offset: 2, clamp: true, clip: false,
              font: { weight: 'bold', size: 12 },
              formatter: function (value) { return String(Math.round(Number(value))); }
            } : undefined
          },
          scales: {
            y: { beginAtZero: true, ticks: { color: '#ffffff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
            x: { ticks: { color: '#ffffff' }, grid: { color: 'rgba(255,255,255,0.05)' } }
          }
        },
        plugins: useDatalabels ? [ChartDataLabels] : [SimpleValueLabels]
      });
    }

    /* ======= Plugins % por barra ======= */
    const PerBarPercentLabelsPlugin = { id: 'perBarPercentLabels', afterDatasetsDraw: function (ch, a, o) { try { if (!ch.canvas || ch.canvas.id !== 'chartResponsables') return; drawPercentsGeneric(ch, o); } catch (e) { console.warn(e); } } };
    const PerBarPercentLabelsPluginCat = { id: 'perBarPercentLabelsCat', afterDatasetsDraw: function (ch, a, o) { try { if (!ch.canvas || ch.canvas.id !== 'chartCategoria') return; drawPercentsGeneric(ch, o); } catch (e) { console.warn(e); } } };
    const PerBarPercentLabelsPluginProv = { id: 'perBarPercentLabelsProv', afterDatasetsDraw: function (ch, a, o) { try { if (!ch.canvas || ch.canvas.id !== 'chartProveedor') return; drawPercentsGeneric(ch, o); } catch (e) { console.warn(e); } } };
    const PerBarPercentLabelsPluginTime = { id: 'perBarPercentLabelsTime', afterDatasetsDraw: function (ch, a, o) { try { if (!ch.canvas || ch.canvas.id !== 'chartTiempo') return; drawPercentsGeneric(ch, o); } catch (e) { console.warn(e); } } };
    const PerBarPercentLabelsPluginServ = { id: 'perBarPercentLabelsServ', afterDatasetsDraw: function (ch, a, o) { try { if (!ch.canvas || ch.canvas.id !== 'chartServicio') return; drawPercentsGeneric(ch, o); } catch (e) { console.warn(e); } } };
    function drawPercentsGeneric(chart, pluginOptions) {
      const opts = pluginOptions || {};
      const mapping = opts.mapping || null;
      const color = opts.color || '#ffffff';
      const inside = !!opts.inside;
      if (!mapping) return;
      const ctx = chart.ctx;
      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 12px system-ui,Segoe UI,Roboto,Arial';
      function drawText(txt, x, y) {
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 3;
        ctx.strokeText(txt, x, y);
        ctx.fillText(txt, x, y);
      }
      Object.keys(mapping).forEach(function (dsIndexStr) {
        const dsIndex = Number(dsIndexStr);
        const meta = chart.getDatasetMeta(dsIndex);
        const percArr = mapping[dsIndex];
        if (!meta || !meta.data || !Array.isArray(percArr)) return;
        meta.data.forEach(function (bar, i) {
          const p = percArr[i];
          if (p === null || p === undefined) return;
          const txt = String(Math.round(p)) + '%';
          const x = bar.x;
          var baseScaleY = undefined;
          if (chart.scales && chart.scales.y && typeof chart.scales.y.getPixelForValue === 'function') {
            baseScaleY = chart.scales.y.getPixelForValue(0);
          }
          const base = (typeof bar.base === 'number') ? bar.base : baseScaleY;
          var y = (typeof base === 'number') ? (bar.y + base) / 2 : (bar.y - 8);
          if (!inside) y = bar.y - 8;
          drawText(txt, x, y);
        });
      });
      ctx.restore();
    }

    /* ======= Barras multi-dataset con % ======= */
    function buildMultiBar(id, labels, datasets, options) {
      options = options || {};
      const ctx = document.getElementById(id); if (!ctx) return; destroyChart(id);
      const useDatalabels = (typeof ChartDataLabels !== 'undefined');
      const pluginsArr = [];
      if (useDatalabels) pluginsArr.push(ChartDataLabels);
      if (options.showEachBarPercentLabels && options.percentsByDataset) {
        if (id === 'chartCategoria') pluginsArr.push(PerBarPercentLabelsPluginCat);
        else if (id === 'chartProveedor') pluginsArr.push(PerBarPercentLabelsPluginProv);
        else if (id === 'chartTiempo') pluginsArr.push(PerBarPercentLabelsPluginTime);
        else if (id === 'chartServicio') pluginsArr.push(PerBarPercentLabelsPluginServ);
        else pluginsArr.push(PerBarPercentLabelsPlugin);
      }
      charts[id] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels.map(function (l) { return cleanText(String(l)); }),
          datasets: datasets.map(function (ds) {
            return {
              label: cleanText(ds.label),
              data: ds.data,
              backgroundColor: ds.backgroundColor,
              borderColor: ds.borderColor || '#0b1220',
              borderWidth: 1
            };
          })
        },
        options: {
          responsive: true, maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#ffffff', font: { size: 14, weight: 'bold' } } },
            tooltip: {
              enabled: true,
              titleColor: '#ffffff',
              bodyColor: '#ffffff',
              callbacks: {
                label: function (ctx) {
                  const dsIndex = ctx.datasetIndex;
                  const i = ctx.dataIndex;
                  const val = ctx.raw;
                  var pctTxt = '';
                  try {
                    const mapping = options.percentsByDataset || {};
                    const arr = mapping[dsIndex] || null;
                    if (arr && typeof arr[i] === 'number') pctTxt = ' (' + Math.round(arr[i]) + '%)';
                  } catch (e) { }
                  const shownVal = Math.round(Number(val));
                  return ctx.dataset.label + ': ' + shownVal + pctTxt;
                }
              }
            },
            datalabels: useDatalabels ? {
              color: '#ffffff', anchor: 'end', align: 'end', offset: 2, clamp: true, clip: false,
              font: { weight: 'bold', size: 12 },
              formatter: function (value) { return String(Math.round(Number(value))); }
            } : undefined,
            perBarPercentLabels: (id !== 'chartCategoria' && id !== 'chartProveedor' && id !== 'chartTiempo' && id !== 'chartServicio' && options.showEachBarPercentLabels)
              ? { mapping: options.percentsByDataset, color: options.percentTextColor || '#ffffff', inside: !!options.percentInside } : undefined,
            perBarPercentLabelsCat: (id === 'chartCategoria' && options.showEachBarPercentLabels)
              ? { mapping: options.percentsByDataset, color: options.percentTextColor || '#ffffff', inside: !!options.percentInside } : undefined,
            perBarPercentLabelsProv: (id === 'chartProveedor' && options.showEachBarPercentLabels)
              ? { mapping: options.percentsByDataset, color: options.percentTextColor || '#ffffff', inside: !!options.percentInside } : undefined,
            perBarPercentLabelsTime: (id === 'chartTiempo' && options.showEachBarPercentLabels)
              ? { mapping: options.percentsByDataset, color: options.percentTextColor || '#ffffff', inside: !!options.percentInside } : undefined,
            perBarPercentLabelsServ: (id === 'chartServicio' && options.showEachBarPercentLabels)
              ? { mapping: options.percentsByDataset, color: options.percentTextColor || '#ffffff', inside: !!options.percentInside } : undefined
          },
          scales: {
            y: { beginAtZero: true, stacked: !!options.stacked, ticks: { color: '#ffffff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
            x: { stacked: !!options.stacked, ticks: { color: '#ffffff' }, grid: { color: 'rgba(255,255,255,0.05)' } }
          }
        },
        plugins: pluginsArr
      });
    }

    /* ===================== KPI Incidentes ===================== */
    function buildKPIIncidentes(id, total) {
      destroyChart(id);
      const ctx = document.getElementById(id); if (!ctx) return;
      charts[id] = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: ['Incidentes Reportados'], datasets: [{ data: [total], backgroundColor: ['#4cc9f0'], borderColor: '#0b1220', borderWidth: 1, cutout: '70%' }] },
        options: {
          responsive: true, maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: { display: true, text: cleanText('Incidentes Reportados'), color: '#ffffff', font: { size: 16, weight: 'bold' } },
            centerText: { title: cleanText('Total'), value: String(Math.round(total)), color: '#ffffff', titleSize: 14, valueSize: 32, gap: 8 }
          }
        },
        plugins: [CenterTextPlugin]
      });
    }

    /* ===================== Estado (pastel con %) ===================== */
    function buildPieWithTitle(id, data, label, titleText) {
      destroyChart(id);
      const ctx = document.getElementById(id); if (!ctx) return;
      const colors = ['#4cc9f0', '#e76f51', '#b5179e', '#4361ee', '#2a9d8f', '#ffbe0b'];
      const labels = data.map(function (d) { return cleanText(String(d.label)); });
      const values = data.map(function (d) { return d.value; });
      const total = values.reduce(function (a, b) { return a + (Number(b) || 0); }, 0);
      const useDatalabels = (typeof ChartDataLabels !== 'undefined');
      const PiePercentFallback = {
        id: 'piePercentFallback',
        afterDatasetsDraw: function (chart) {
          if (useDatalabels) return;
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          if (!meta || !meta.data) return;
          ctx.save();
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = 'bold 12px system-ui,Segoe UI,Roboto,Arial';
          meta.data.forEach(function (arc, i) {
            const val = Number(values[i]) || 0;
            const pct = total ? Math.round((val / total) * 100) : 0;
            const pos = arc.tooltipPosition();
            const txt = String(pct) + '%';
            ctx.strokeStyle = 'rgba(0,0,0,0.45)'; ctx.lineWidth = 3;
            ctx.strokeText(txt, pos.x, pos.y);
            ctx.fillText(txt, pos.x, pos.y);
          });
          ctx.restore();
        }
      };
      charts[id] = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            label: cleanText(label),
            data: values,
            backgroundColor: values.map(function (_, i) { return colors[i % colors.length]; }),
            borderColor: '#0b1220',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#ffffff', font: { size: 16, weight: 'bold' } } },
            title: { display: !!titleText, text: cleanText(titleText || ''), color: '#ffffff', font: { size: 16, weight: 'bold' } },
            tooltip: {
              enabled: true, titleColor: '#ffffff', bodyColor: '#ffffff',
              callbacks: {
                label: function (ctx) {
                  const val = Number(ctx.raw) || 0;
                  const pct = total ? Math.round((val / total) * 100) : 0;
                  return ctx.label + ': ' + Math.round(val) + ' (' + pct + '%)';
                }
              }
            },
            datalabels: useDatalabels ? {
              color: '#ffffff', anchor: 'center', align: 'center', clamp: true, clip: false,
              font: { weight: 'bold', size: 12 },
              formatter: function (val) {
                const pct = total ? Math.round((Number(val) / total) * 100) : 0;
                return String(pct) + '%';
              }
            } : undefined
          }
        },
        plugins: useDatalabels ? [ChartDataLabels] : [PiePercentFallback]
      });
    }

    /* ===================== C√°lculos ===================== */
    function getOpenClosedTotals(rows, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      var abiertos = 0, cerrados = 0;
      rows.forEach(function (r) {
        const s = norm(r[stateCol] || '');
        if (!s) return;
        if (OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; })) abiertos++;
        else if (CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; })) cerrados++;
      });
      return { abiertos: abiertos, cerrados: cerrados, total: abiertos + cerrados };
    }
    function getOpenClosedReturnedEmptyTotals(rows, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const RETURNED_TERMS = ['devuelto', 'returned'];
      var abiertos = 0, cerrados = 0, devuelto = 0, vacios = 0;
      rows.forEach(function (r) {
        const raw = r[stateCol];
        const s = norm(raw || '');
        if (!raw || s === '') { vacios++; return; }
        if (OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; })) abiertos++;
        else if (CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; })) cerrados++;
        else if (RETURNED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; })) devuelto++;
      });
      const total = abiertos + cerrados + devuelto + vacios;
      return { abiertos: abiertos, cerrados: cerrados, devuelto: devuelto, vacios: vacios, total: total };
    }
    function getOpenClosedByResponsible(rows, respCol, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const map = new Map();
      rows.forEach(function (r) {
        const resp = cleanText(r[respCol] || '').trim();
        const s = norm(r[stateCol] || '');
        if (!resp || !s) return;
        const isOpen = OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        const isClosed = CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        if (!isOpen && !isClosed) return;
        if (!map.has(resp)) map.set(resp, { abiertos: 0, cerrados: 0 });
        const entry = map.get(resp);
        if (isOpen) entry.abiertos += 1; else if (isClosed) entry.cerrados += 1;
      });
      return Array.from(map.entries())
        .map(function (pair) { return { label: pair[0], abiertos: pair[1].abiertos, cerrados: pair[1].cerrados, total: pair[1].abiertos + pair[1].cerrados }; })
        .sort(function (a, b) { return b.total - a.total; });
    }
    function getOpenClosedByCategory(rows, categoryCol, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const map = new Map();
      rows.forEach(function (r) {
        const cat = cleanText(r[categoryCol] || '').trim();
        const s = norm(r[stateCol] || '');
        if (!cat || !s) return;
        const isOpen = OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        const isClosed = CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        if (!isOpen && !isClosed) return;
        if (!map.has(cat)) map.set(cat, { abiertos: 0, cerrados: 0, total: 0 });
        const entry = map.get(cat);
        if (isOpen) entry.abiertos += 1; else if (isClosed) entry.cerrados += 1;
        entry.total = entry.abiertos + entry.cerrados;
      });
      return Array.from(map.entries())
        .map(function (pair) { return { label: pair[0], abiertos: pair[1].abiertos, cerrados: pair[1].cerrados, total: pair[1].total }; })
        .sort(function (a, b) { return b.total - a.total; });
    }
    function getOpenClosedByProvider(rows, providerCol, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const map = new Map();
      rows.forEach(function (r) {
        const prov = cleanText(r[providerCol] || '').trim();
        const s = norm(r[stateCol] || '');
        if (!prov || !s) return;
        const isOpen = OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        const isClosed = CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        if (!isOpen && !isClosed) return;
        if (!map.has(prov)) map.set(prov, { abiertos: 0, cerrados: 0, total: 0 });
        const entry = map.get(prov);
        if (isOpen) entry.abiertos += 1; else if (isClosed) entry.cerrados += 1;
        entry.total = entry.abiertos + entry.cerrados;
      });
      return Array.from(map.entries())
        .map(function (pair) { return { label: pair[0], abiertos: pair[1].abiertos, cerrados: pair[1].cerrados, total: pair[1].total }; })
        .sort(function (a, b) { return b.total - a.total; });
    }

    /* ===================== Tiempo (promedio) ===================== */
    function getAvgTimeByRangeAndState(rows, rangeCol, timeCol, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const buckets = new Map();
      rows.forEach(function (r) {
        const range = cleanText(r[rangeCol] || '').trim();
        const s = norm(r[stateCol] || '');
        const time = parseNumber(r[timeCol]);
        if (!range || !s || isNaN(time)) return;
        const isOpen = OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        const isClosed = CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        if (!isOpen && !isClosed) return;
        if (!buckets.has(range)) buckets.set(range, { open: { sum: 0, count: 0 }, closed: { sum: 0, count: 0 } });
        const b = buckets.get(range);
        if (isOpen) { b.open.sum += time; b.open.count += 1; }
        if (isClosed) { b.closed.sum += time; b.closed.count += 1; }
      });
      const rowsOut = Array.from(buckets.entries()).map(function (pair) {
        const range = pair[0], b = pair[1];
        const avgOpen = b.open.count ? b.open.sum / b.open.count : 0;
        const avgClosed = b.closed.count ? b.closed.sum / b.closed.count : 0;
        return {
          label: range,
          avgOpen: Number(avgOpen.toFixed(2)),
          avgClosed: Number(avgClosed.toFixed(2)),
          countOpen: b.open.count,
          countClosed: b.closed.count,
          weight: getRangeWeight(range)
        };
      });
      rowsOut.sort(function (a, b) { return (a.weight === b.weight) ? String(a.label).localeCompare(String(b.label)) : (a.weight - b.weight); });
      return rowsOut;
    }
    function getAvgTimeByStateGlobal(rows, timeCol, stateCol) {
      const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
      const CLOSED_TERMS = ['cerrado', 'closed', 'resuelto', 'finalizado', 'completado'];
      const acc = { open: { sum: 0, count: 0 }, closed: { sum: 0, count: 0 } };
      rows.forEach(function (r) {
        const s = norm(r[stateCol] || '');
        const time = parseNumber(r[timeCol]);
        if (!s || isNaN(time)) return;
        const isOpen = OPEN_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        const isClosed = CLOSED_TERMS.some(function (t) { return s.indexOf(norm(t)) >= 0; });
        if (!isOpen && !isClosed) return;
        if (isOpen) { acc.open.sum += time; acc.open.count += 1; }
        if (isClosed) { acc.closed.sum += time; acc.closed.count += 1; }
      });
      const avgOpen = acc.open.count ? acc.open.sum / acc.open.count : 0;
      const avgClosed = acc.closed.count ? acc.closed.sum / acc.closed.count : 0;
      return {
        label: 'Global',
        avgOpen: Number(avgOpen.toFixed(2)),
        avgClosed: Number(avgClosed.toFixed(2)),
        countOpen: acc.open.count,
        countClosed: acc.closed.count
      };
    }

    /* ===================== Render adaptativo: gr√°ficas ===================== */
    function renderChartsAdaptive() {
      const ids = ['chartIncidentes', 'chartEstado', 'chartTiempo', 'chartResponsables', 'chartServicio', 'chartProveedor', 'chartCategoria'];
      ids.forEach(destroyChart);
      if (!rawData.length) { ids.forEach(showPlaceholder); return; }
      const headers = Object.keys(rawData[0] || {});
      schema = inferSchema(headers, rawData);
      // KPI 
      buildKPIIncidentes('chartIncidentes', rawData.length);
      // Estado (pastel con %) 
      const FIXED_STATE_COL = 'Estado Final Incidente';
      const colEstado = headers.indexOf(FIXED_STATE_COL) >= 0 ? FIXED_STATE_COL : (schema.roles.estado || null);
      if (colEstado) {
        const totals = getOpenClosedReturnedEmptyTotals(rawData, colEstado);
        const pieData = [
          { label: 'Abiertos (' + totals.abiertos + ')', value: totals.abiertos },
          { label: 'Cerrados (' + totals.cerrados + ')', value: totals.cerrados },
          { label: 'Devuelto (' + totals.devuelto + ')', value: totals.devuelto },
          { label: 'Vac√≠os (' + totals.vacios + ')', value: totals.vacios }
        ];
        buildPieWithTitle('chartEstado', pieData, 'Abiertos vs Cerrados', 'Total: ' + totals.total);
      } else { showPlaceholder('chartEstado'); }

      // Tiempo (Promedio) ‚Äî Ahora muestra totales Abiertos vs Cerrados por categor√≠a (Rango edad)
      var colTiempo = schema.roles.tiempo;
      // mantiene tu preferencia para detectar la columna de tiempo si hubiera varias
      const preferidasTiempo = [/edad\s*incidente/i, /dias?\s*(ans|entrega|compromiso)?/i, /tiempo/i];
      const preferida = headers.find(h => preferidasTiempo.some(rx => rx.test(h)));
      if (preferida) colTiempo = preferida;

      // Forzar el uso de la columna exacta "Rango edad"
      const FIXED_RANGE_COL = 'Rango edad';
      const colRango = headers.indexOf(FIXED_RANGE_COL) >= 0 ? FIXED_RANGE_COL : null; // ‚Üê NO permitimos fallback autom√°tico

      if (colEstado && colTiempo && colRango) {
        // En lugar de promedios, calculamos totales (abiertos/cerrados) por rango
        const rowsCat = getOpenClosedByCategory(rawData, colRango, colEstado);
        if (rowsCat.length) {
          // Orden preferido solicitado por el usuario
          const desiredOrder = ['Menor a 1 a√±o', 'Menor a 180 d√≠as', 'Menor a 2 a√±os', 'Menor a 3 a√±os', 'Menor a 30 d√≠as', 'Menor a 60 d√≠as', 'Menor a 90 d√≠as'];
          const mapCat = {};
          rowsCat.forEach(function (r) { mapCat[cleanText(r.label)] = r; });

          const ordered = [];
          desiredOrder.forEach(function (d) {
            const key = cleanText(d);
            if (mapCat[key]) ordered.push(mapCat[key]);
          });
          // A√±adir categor√≠as restantes en el orden encontrado
          rowsCat.forEach(function (r) {
            const k = cleanText(r.label);
            if (!ordered.find(function (o) { return cleanText(o.label) === k; })) ordered.push(r);
          });

          const labels = ordered.map(function (r) { return r.label; });
          const abiertos = ordered.map(function (r) { return r.abiertos; });
          const cerrados = ordered.map(function (r) { return r.cerrados; });
          const percOpen = ordered.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.abiertos / tot) * 100 : 0; });
          const percClosed = ordered.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.cerrados / tot) * 100 : 0; });

          buildMultiBar('chartTiempo', labels, [
            { label: 'Abiertos', data: abiertos, backgroundColor: '#4cc9f0', borderColor: '#3182ce' },
            { label: 'Cerrados', data: cerrados, backgroundColor: '#2a9d8f', borderColor: '#1f776b' }
          ], {
            stacked: false,
            showEachBarPercentLabels: true,
            percentsByDataset: { 0: percOpen, 1: percClosed },
            percentTextColor: '#ffffff',
            percentInside: true
          });
        } else {
          showPlaceholder('chartTiempo');
        }
      } else {
        showPlaceholder('chartTiempo');
        console.warn('La gr√°fica "Tiempo Tickets (Promedio)" requiere la columna exacta "Rango edad".');
        if (!headers.includes(FIXED_RANGE_COL)) {
          alert('La gr√°fica "Tiempo Tickets (Promedio)" requiere la columna exacta "Rango edad" en el CSV.');
        }
      }

      // Responsables 
      const FIXED_RESP_COL = 'Ingeniero Asignado';
      const colResp = headers.indexOf(FIXED_RESP_COL) >= 0 ? FIXED_RESP_COL : (schema.roles.responsable || null);
      if (colResp && colEstado) {
        const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
        const labels = rowsResp.map(function (r) { return r.label; });
        const abiertos = rowsResp.map(function (r) { return r.abiertos; });
        const cerrados = rowsResp.map(function (r) { return r.cerrados; });
        const percAbiertos = rowsResp.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.abiertos / tot) * 100 : 0; });
        const percCerrados = rowsResp.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.cerrados / tot) * 100 : 0; });
        buildMultiBar('chartResponsables', labels, [
          { label: 'Abiertos', data: abiertos, backgroundColor: '#4cc9f0', borderColor: '#3182ce' },
          { label: 'Cerrados', data: cerrados, backgroundColor: '#2a9d8f', borderColor: '#1f776b' }
        ], {
          stacked: false, showEachBarPercentLabels: true,
          percentsByDataset: { 0: percAbiertos, 1: percCerrados },
          percentTextColor: '#ffffff', percentInside: true
        });
      } else { showPlaceholder('chartResponsables'); }
      // Servicio (Solo Abiertos)
      const colServ = schema.roles.servicio;
      if (colServ) {
        const OPEN_TERMS = ['abierto', 'open', 'pendiente', 'en progreso', 'en curso', 'asignado', 'reabierto'];
        const casosAbiertos = rawData.filter(function (r) {
          const estado = norm(String(r[colEstado] || ''));
          return OPEN_TERMS.some(function (t) { return estado.indexOf(norm(t)) >= 0; });
        });
        const counts = countBy(casosAbiertos, colServ).map(function (d) { return { label: cleanText(d.label), value: Math.round(d.value) }; });
        const labels = counts.map(function (d) { return d.label; });
        const valores = counts.map(function (d) { return d.value; });
        const totalServ = valores.reduce(function (a, b) { return a + (Number(b) || 0); }, 0);
        const percServicios = valores.map(function (v) { return totalServ ? (Number(v) / totalServ) * 100 : 0; });
        buildMultiBar('chartServicio', labels, [
          { label: 'Casos Abiertos', data: valores, backgroundColor: '#90cdf4', borderColor: '#3182ce' }
        ], {
          stacked: false, showEachBarPercentLabels: true,
          percentsByDataset: { 0: percServicios },
          percentTextColor: '#ffffff', percentInside: true
        });
      } else { showPlaceholder('chartServicio'); }
      // Proveedor 
      const FIXED_PROV_COL = 'Proveedor a escalar';
      const colProv = headers.indexOf(FIXED_PROV_COL) >= 0 ? FIXED_PROV_COL : (schema.roles.proveedor || null);
      if (colProv && colEstado) {
        const rowsProv = getOpenClosedByProvider(rawData, colProv, colEstado);
        const labels = rowsProv.map(function (r) { return r.label; });
        const abiertos = rowsProv.map(function (r) { return r.abiertos; });
        const cerrados = rowsProv.map(function (r) { return r.cerrados; });
        const percAbiertosProv = rowsProv.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.abiertos / tot) * 100 : 0; });
        const percCerradosProv = rowsProv.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.cerrados / tot) * 100 : 0; });
        buildMultiBar('chartProveedor', labels, [
          { label: 'Abiertos', data: abiertos, backgroundColor: '#4cc9f0', borderColor: '#3182ce' },
          { label: 'Cerrados', data: cerrados, backgroundColor: '#2a9d8f', borderColor: '#1f776b' }
        ], {
          stacked: false, showEachBarPercentLabels: true,
          percentsByDataset: { 0: percAbiertosProv, 1: percCerradosProv },
          percentTextColor: '#ffffff', percentInside: true
        });
      } else { showPlaceholder('chartProveedor'); }
      // Categor√≠a 
      const FIXED_CAT_COL = 'Categor√≠a';
      const colCat = headers.indexOf(FIXED_CAT_COL) >= 0 ? FIXED_CAT_COL : (headers.find(function (h) { return /categor[i√≠]a/i.test(h); }) || null);
      if (colCat && colEstado) {
        const rowsCat = getOpenClosedByCategory(rawData, colCat, colEstado);
        const labels = rowsCat.map(function (r) { return r.label; });
        const abiertos = rowsCat.map(function (r) { return r.abiertos; });
        const cerrados = rowsCat.map(function (r) { return r.cerrados; });
        const percAbiertosCat = rowsCat.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.abiertos / tot) * 100 : 0; });
        const percCerradosCat = rowsCat.map(function (r) { var tot = r.abiertos + r.cerrados; return tot ? (r.cerrados / tot) * 100 : 0; });
        buildMultiBar('chartCategoria', labels, [
          { label: 'Abiertos', data: abiertos, backgroundColor: '#4cc9f0', borderColor: '#3182ce' },
          { label: 'Cerrados', data: cerrados, backgroundColor: '#2a9d8f', borderColor: '#1f776b' }
        ], {
          stacked: false, showEachBarPercentLabels: true,
          percentsByDataset: { 0: percAbiertosCat, 1: percCerradosCat },
          percentTextColor: '#ffffff', percentInside: true
        });
      } else { showPlaceholder('chartCategoria'); }
    }

    /* ===================== Exportaci√≥n PDF ===================== */
    function fmtInt(n) { return Math.round(Number(n || 0)); }
    function fmtPctInt(part, total) { var t = Number(total || 0); if (!t) return 0; return Math.round((Number(part || 0) / t) * 100); }
    function buildCountTableRows(pairs) {
      const total = pairs.reduce(function (a, b) { return a + Number(b.value || 0); }, 0);
      return pairs.map(function (p) { return [cleanText(String(p.label)), fmtInt(p.value), String(fmtPctInt(p.value, total)) + '%']; });
    }
    function buildResponsablesTableRows(rowsResp) {
      return rowsResp.map(function (r) {
        const tot = (r.abiertos || 0) + (r.cerrados || 0);
        return [cleanText(String(r.label)), fmtInt(r.abiertos), String(fmtPctInt(r.abiertos, tot)) + '%', fmtInt(r.cerrados), String(fmtPctInt(r.cerrados, tot)) + '%', fmtInt(tot)];
      });
    }
    function buildABvsCTableRows(rows) {
      return rows.map(function (r) {
        const tot = (r.abiertos || 0) + (r.cerrados || 0);
        return [cleanText(String(r.label)), fmtInt(r.abiertos), String(fmtPctInt(r.abiertos, tot)) + '%', fmtInt(r.cerrados), String(fmtPctInt(r.cerrados, tot)) + '%', fmtInt(tot)];
      });
    }
    function buildServicioTableRows(counts) {
      const total = counts.reduce(function (a, b) { return a + Number(b.value || 0); }, 0);
      return counts.map(function (d) { return [cleanText(String(d.label)), fmtInt(d.value), String(fmtPctInt(d.value, total)) + '%']; });
    }
    function buildTiempoTableRows(rowsTiempo, isGlobal) {
      isGlobal = !!isGlobal;
      if (isGlobal) {
        const r = rowsTiempo;
        const tot = (r.countOpen || 0) + (r.countClosed || 0);
        return [['Global', fmtInt(r.avgOpen), String(fmtPctInt(r.countOpen, tot)) + '%', fmtInt(r.avgClosed), String(fmtPctInt(r.countClosed, tot)) + '%', fmtInt(tot)]];
      } else {
        return rowsTiempo.map(function (r) {
          const tot = (r.countOpen || 0) + (r.countClosed || 0);
          return [cleanText(String(r.label)), fmtInt(r.avgOpen), String(fmtPctInt(r.countOpen, tot)) + '%', fmtInt(r.avgClosed), String(fmtPctInt(r.countClosed, tot)) + '%', fmtInt(tot)];
        });
      }
    }
    function addTable(doc, head, body, startY, columnStyles) {
      columnStyles = columnStyles || {};
      doc.autoTable({
        startY: startY,
        head: [head],
        body: body,
        theme: 'grid',
        headStyles: { fillColor: [67, 97, 238], textColor: 255, fontStyle: 'bold', halign: 'center' },
        styles: { font: 'helvetica', fontSize: 9, cellPadding: 4, overflow: 'linebreak', cellWidth: 'wrap' },
        bodyStyles: { minCellHeight: 14 },
        alternateRowStyles: { fillColor: [245, 247, 250] },
        columnStyles: columnStyles,
        margin: { left: 40, right: 40 },
        pageBreak: 'auto',
        rowPageBreak: 'auto'
      });
      return (doc.lastAutoTable && doc.lastAutoTable.finalY) ? doc.lastAutoTable.finalY : startY;
    }
    function getLogoDataUrl() {
      const img = document.getElementById('logoCorp');
      if (!img || !(img.complete && img.naturalWidth)) return null;
      const w = img.naturalWidth || 600;
      const h = img.naturalHeight || 200;
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      return c.toDataURL('image/png', 1.0);
    }
    function drawHeader(doc, titleText, palette) {
      palette = palette || { bg: { r: 12, g: 18, b: 32 }, text: { r: 255, g: 255, b: 255 } };
      const pageWidth = doc.internal.pageSize.getWidth();
      const headerH = 60;
      doc.setFillColor(palette.bg.r, palette.bg.g, palette.bg.b);
      doc.rect(0, 0, pageWidth, headerH, 'F');
      try {
        const logo = getLogoDataUrl();
        if (logo) doc.addImage(logo, 'PNG', 40, 5, 160, 50);
      } catch (e) { }
      doc.setTextColor(palette.text.r, palette.text.g, palette.text.b);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(16);
      doc.text(cleanText(titleText), pageWidth / 2, 34, { align: 'center' });
      return headerH + 20;
    }
    function getCanvasForPdfHD(canvasId, targetWidth, targetHeight, scaleFactor) {
      scaleFactor = scaleFactor || 2;
      const source = document.getElementById(canvasId);
      if (!source) return null;
      const temp = document.createElement('canvas');
      temp.width = Math.max(1, Math.floor(targetWidth * scaleFactor));
      temp.height = Math.max(1, Math.floor(targetHeight * scaleFactor));
      const tctx = temp.getContext('2d');
      tctx.fillStyle = '#ffffff';
      tctx.fillRect(0, 0, temp.width, temp.height);
      const sw = source.width || source.clientWidth || 1000;
      const sh = source.height || source.clientHeight || 600;
      const scale = Math.min((targetWidth * scaleFactor) / sw, (targetHeight * scaleFactor) / sh);
      const dw = Math.floor(sw * scale);
      const dh = Math.floor(sh * scale);
      const dx = Math.floor((temp.width - dw) / 2);
      const dy = Math.floor((temp.height - dh) / 2);
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = 'high';
      tctx.drawImage(source, dx, dy, dw, dh);
      return temp;
    }
    function applyPrintTheme(enable) {
      enable = !!enable;
      Object.keys(charts).forEach(function (id) {
        const ch = charts[id];
        if (!ch) return;
        const opts = ch.options || {};
        if (opts.plugins && opts.plugins.legend && opts.plugins.legend.labels) {
          opts.plugins.legend.labels.color = enable ? '#000000' : '#ffffff';
          const curr = opts.plugins.legend.labels.font || {};
          opts.plugins.legend.labels.font = { size: (enable ? 14 : 12), weight: 'bold' };
          for (var k in curr) { if (!(k in opts.plugins.legend.labels.font)) opts.plugins.legend.labels.font[k] = curr[k]; }
        }
        if (opts.plugins && opts.plugins.title) {
          opts.plugins.title.color = enable ? '#000000' : '#ffffff';
          const currT = opts.plugins.title.font || {};
          opts.plugins.title.font = { size: (enable ? 16 : 14), weight: 'bold' };
          for (var k2 in currT) { if (!(k2 in opts.plugins.title.font)) opts.plugins.title.font[k2] = currT[k2]; }
        }
        if (opts.scales && opts.scales.x && opts.scales.x.ticks) {
          opts.scales.x.ticks.color = enable ? '#000000' : '#ffffff';
          const currX = opts.scales.x.ticks.font || {};
          opts.scales.x.ticks.font = { size: (enable ? 12 : 11), weight: 'bold' };
          for (var k3 in currX) { if (!(k3 in opts.scales.x.ticks.font)) opts.scales.x.ticks.font[k3] = currX[k3]; }
        }
        if (opts.scales && opts.scales.y && opts.scales.y.ticks) {
          opts.scales.y.ticks.color = enable ? '#000000' : '#ffffff';
          const currY = opts.scales.y.ticks.font || {};
          opts.scales.y.ticks.font = { size: (enable ? 12 : 11), weight: 'bold' };
          for (var k4 in currY) { if (!(k4 in opts.scales.y.ticks.font)) opts.scales.y.ticks.font[k4] = currY[k4]; }
        }
        ch.update('none');
      });
    }

    /* ====== Narrativa Ejecutiva (Camino A, sin LLM) ====== */
    function buildExecutiveNarrative(rawData, schema) {
      const headers = Object.keys(rawData[0] || {});
      const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : (schema && schema.roles ? schema.roles.estado : null);
      const colTiempo = (schema && schema.roles ? schema.roles.tiempo : null);
      const colResp = headers.includes('Ingeniero Asignado') ? 'Ingeniero Asignado' : (schema && schema.roles ? schema.roles.responsable : null);
      const colServ = (schema && schema.roles ? schema.roles.servicio : null);
      const colProv = headers.includes('Proveedor a escalar') ? 'Proveedor a escalar' : (schema && schema.roles ? schema.roles.proveedor : null);

      const total = rawData.length;
      const oc = colEstado ? getOpenClosedTotals(rawData, colEstado) : { abiertos: 0, cerrados: 0, total: total };

      let promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        promedioTiempo = tiempos.length ? average(tiempos) : 0;
      }

      const respRows = (colResp && colEstado) ? getOpenClosedByResponsible(rawData, colResp, colEstado) : [];
      const provRows = (colProv && colEstado) ? getOpenClosedByProvider(rawData, colProv, colEstado) : [];
      const servCounts = (colServ) ? countBy(rawData, colServ) : [];

      const topRespAbiertos = respRows.slice().sort((a, b) => b.abiertos - a.abiertos).slice(0, 5);
      const topProvAbiertos = provRows.slice().sort((a, b) => b.abiertos - a.abiertos).slice(0, 5);
      const topServicios = servCounts.slice().sort((a, b) => b.value - a.value).slice(0, 5);

      const tasaResol = total ? (oc.cerrados / total) * 100 : 0;
      const cicloLento = promedioTiempo > 30;
      const backlogAlto = oc.abiertos > oc.cerrados;

      const resumen = [
        `Se analizaron ${total} incidentes.`,
        `La tasa de resoluci√≥n es ${Math.round(tasaResol)}%.`,
        `El tiempo promedio del ciclo es ${Math.round(promedioTiempo)} d√≠as.`,
        backlogAlto ? `El backlog actual requiere atenci√≥n (abiertos > cerrados).` : `El backlog se mantiene bajo control.`,
        cicloLento ? `El ciclo operativo muestra lentitud (promedio > 30 d√≠as).` : `El ciclo operativo se mantiene dentro de par√°metros aceptables.`
      ];

      const riesgos = [
        backlogAlto ? `Incremento de casos abiertos frente a los cerrados.` : null,
        cicloLento ? `Tiempo de ciclo elevado‚Äîriesgo de incumplimiento de ANS.` : null,
        (topRespAbiertos[0]?.abiertos || 0) > 0 ? `Concentraci√≥n de backlog en ciertos responsables.` : null,
        (topProvAbiertos[0]?.abiertos || 0) > 0 ? `Dependencia de proveedores con cola de cierre alta.` : null
      ].filter(Boolean);

      const acciones = [
        `Priorizar cierre de los Top-5 responsables con m√°s abiertos.`,
        `Escalar con los Top-5 proveedores cr√≠ticos.`,
        `Revisar causas en los servicios con mayor volumen (Top-5) y definir planes de mitigaci√≥n.`,
        cicloLento ? `Implementar SLA internos para reducir el tiempo promedio y reforzar monitoreo diario.` : `Mantener el ritmo de cierre y monitoreo semanal.`
      ];

      return { resumen, riesgos, acciones, topRespAbiertos, topProvAbiertos, topServicios };
    }
    function addExecutiveInsightsToPdf(doc, narrative, startY) {
      let y = startY;
      doc.setFont('helvetica', 'bold'); doc.setFontSize(12);
      doc.text('Resumen Ejecutivo', 40, y); y += 14;
      doc.setFont('helvetica', 'normal'); doc.setFontSize(10);

      narrative.resumen.forEach(line => { doc.text(cleanText(line), 40, y); y += 12; });

      y += 6; doc.setFont('helvetica', 'bold'); doc.text('Riesgos/Se√±ales', 40, y); y += 14;
      doc.setFont('helvetica', 'normal');
      narrative.riesgos.forEach(line => { doc.text('‚Ä¢ ' + cleanText(line), 40, y); y += 12; });

      y += 6; doc.setFont('helvetica', 'bold'); doc.text('Acciones recomendadas (pr√≥ximos 30 d√≠as)', 40, y); y += 14;
      doc.setFont('helvetica', 'normal');
      narrative.acciones.forEach(line => { doc.text('‚Ä¢ ' + cleanText(line), 40, y); y += 12; });

      const headResp = ['Responsable', 'Abiertos', 'Cerrados', 'Total'];
      const bodyResp = narrative.topRespAbiertos.map(r => [cleanText(r.label), fmtInt(r.abiertos), fmtInt(r.cerrados), fmtInt(r.total)]);
      y = addTable(doc, headResp, bodyResp, y + 10, { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 80 }, 3: { cellWidth: 80 } });

      const headProv = ['Proveedor', 'Abiertos', 'Cerrados', 'Total'];
      const bodyProv = narrative.topProvAbiertos.map(r => [cleanText(r.label), fmtInt(r.abiertos), fmtInt(r.cerrados), fmtInt(r.total)]);
      y = addTable(doc, headProv, bodyProv, y + 10, { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 80 }, 3: { cellWidth: 80 } });

      const headServ = ['Servicio', 'Casos', '% del total'];
      const bodyServ = buildCountTableRows(narrative.topServicios.map(s => ({ label: s.label, value: s.value })));
      addTable(doc, headServ, bodyServ, y + 10, { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 100 } });
    }

    /* ====== *** NUEVO (Camino B) *** Generar narrativa con LLM local ====== */
    /** Construye el payload con KPIs y Top-5 para el prompt del LLM */
    function buildKpiPayload(schema, headers) {
      const FIXED_STATE_COL = 'Estado Final Incidente';
      const colEstado = headers.indexOf(FIXED_STATE_COL) >= 0 ? FIXED_STATE_COL : (schema.roles.estado || null);
      const totalIncidentes = rawData.length;
      const openClosed = colEstado ? getOpenClosedTotals(rawData, colEstado) : { abiertos: 0, cerrados: 0, total: totalIncidentes };

      const colTiempo = schema.roles.tiempo || null;
      let promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        if (tiempos.length) promedioTiempo = average(tiempos);
      }

      const FIXED_RESP_COL = 'Ingeniero Asignado';
      const colResp = headers.indexOf(FIXED_RESP_COL) >= 0 ? FIXED_RESP_COL : (schema.roles.responsable || null);
      const FIXED_PROV_COL = 'Proveedor a escalar';
      const colProv = headers.indexOf(FIXED_PROV_COL) >= 0 ? FIXED_PROV_COL : (schema.roles.proveedor || null);
      const colServ = schema.roles.servicio || null;

      const topResp = (colResp && colEstado) ? getOpenClosedByResponsible(rawData, colResp, colEstado).slice(0, 5) : [];
      const topProv = (colProv && colEstado) ? getOpenClosedByProvider(rawData, colProv, colEstado).slice(0, 5) : [];
      const topServ = (colServ) ? countBy(rawData, colServ).slice(0, 5) : [];

      const tasaResolucion = Math.round((openClosed.cerrados / Math.max(1, totalIncidentes)) * 100);

      return {
        totalIncidentes,
        abiertos: openClosed.abiertos,
        cerrados: openClosed.cerrados,
        tiempoPromedioDias: Math.round(promedioTiempo),
        tasaResolucion,
        topResponsables: topResp,
        topProveedores: topProv,
        topServicios: topServ
      };
    }

    /** LLM via Ollama: /api/generate (no stream) ‚Äî respuesta en .response */
    async function llmViaOllama(payloadKPI) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), LLM_TIMEOUT_MS);

      const prompt = `
Act√∫a como analista de operaciones TI para un comit√© directivo.
Con los siguientes indicadores, redacta una narrativa ejecutiva (150‚Äì220 palabras),
incluye 3 riesgos y 4 acciones priorizadas (vi√±etas). S√© claro y espec√≠fico.

Datos:
${JSON.stringify(payloadKPI, null, 2)}
`.trim();

      const res = await fetch(LLM_OLLAMA_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: LLM_OLLAMA_MODEL,
          prompt,
          stream: false,        // respuesta completa en un JSON
          options: { temperature: 0.7 }
        }),
        signal: controller.signal,
        mode: 'cors'           // si usas CORS con OLLAMA_ORIGINS
      });
      clearTimeout(t);
      if (!res.ok) throw new Error(`Ollama error HTTP ${res.status}`);
      const json = await res.json();
      // Ollama devuelve { response: "..." , done: true, ... }
      return String(json.response || '').trim();
    }

    /** LLM via LM Studio: /v1/chat/completions (OpenAI-compatible) */
    async function llmViaLmStudio(payloadKPI) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), LLM_TIMEOUT_MS);

      const messages = [
        { role: 'system', content: 'Eres analista de operaciones TI. Respondes con claridad ejecutiva.' },
        {
          role: 'user', content: `
Redacta una narrativa ejecutiva (150‚Äì220 palabras) para comit√© directivo.
Incluye 3 riesgos y 4 acciones priorizadas (vi√±etas). S√© claro y espec√≠fico.

Datos:
${JSON.stringify(payloadKPI, null, 2)}
`.trim()
        }
      ];

      const res = await fetch(LLM_LMSTUDIO_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'your-model-name',   // Ajusta al nombre exacto cargado en LM Studio
          messages,
          stream: false
        }),
        signal: controller.signal
      });
      clearTimeout(t);
      if (!res.ok) throw new Error(`LM Studio error HTTP ${res.status}`);
      const json = await res.json();
      const choice = json && json.choices && json.choices[0];
      const content = choice && (choice.message && choice.message.content);
      return String(content || '').trim();
    }

    /** Unified: intenta provider seleccionado; si falla, devuelve null */
    async function getLLMExecutiveSummary(payloadKPI) {
      if (!LLM_ENABLED) return null;
      try {
        if (LLM_PROVIDER === 'ollama') {
          // Ollama /api/generate, stream=false. Campo "response".  [1](https://docs.ollama.com/api/generate)
          return await llmViaOllama(payloadKPI);
        } else if (LLM_PROVIDER === 'lmstudio') {
          // LM Studio OpenAI-compatible /v1/chat/completions.  [4](https://lmstudio.ai/docs/developer/core/server)
          return await llmViaLmStudio(payloadKPI);
        } else {
          return null;
        }
      } catch (err) {
        console.warn('LLM no disponible / error:', err);
        return null;
      }
    }

    /** A√±ade p√°gina LLM al PDF si hay texto */
    function addLLMPageToPdf(doc, llmText) {
      if (!llmText) return;
      addLandscapePage(doc);
      const y = drawHeader(doc, 'Narrativa (LLM)', { bg: { r: 12, g: 18, b: 32 }, text: { r: 255, g: 255, b: 255 } });
      doc.setFont('helvetica', 'normal'); doc.setFontSize(10);
      const pageWidth = doc.internal.pageSize.getWidth();
      // Ajuste de ancho de texto (m√°rgenes 40‚Äì40)
      const lines = doc.splitTextToSize(cleanText(llmText), pageWidth - 80);
      doc.text(lines, 40, y + 10);
    }

    /* ====== Reporte PDF Ejecutivo ‚Äî Landscape + LLM ====== */
    async function generatePDFReport() {
      if (!rawData.length) {
        alert('No hay datos cargados. Por favor carga un archivo CSV primero.');
        return;
      }
      var jsPDFlib = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : window.jsPDF;
      if (!jsPDFlib) {
        alert('No se encontr√≥ jsPDF. Verifica que el CDN est√© cargado antes de app.js.');
        return;
      }
      const doc = new jsPDFlib(PAGE_ORIENTATION, PAGE_UNIT, PAGE_FORMAT);
      var hasAutoTable = (typeof doc.autoTable === 'function')
        || (jsPDFlib && jsPDFlib.API && typeof jsPDFlib.API.autoTable === 'function')
        || (window.jspdf && typeof window.jspdf.autoTable === 'function');
      if (!hasAutoTable) {
        alert('No se encontr√≥ AutoTable. Verifica que el CDN de jspdf-autotable est√© cargado.');
        return;
      }
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const COLOR_BG = { r: 12, g: 18, b: 32 };
      const COLOR_TEXT = { r: 25, g: 25, b: 25 };

      // Portada + resumen (landscape)
      var y = drawHeader(doc, 'Reporte Ejecutivo ‚Äî Dashboard Incidentes TI', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
      doc.setTextColor(COLOR_TEXT.r, COLOR_TEXT.g, COLOR_TEXT.b);
      doc.setFont('helvetica', 'normal'); doc.setFontSize(10);
      doc.text(cleanText('Fecha de generaci√≥n: ' + new Date().toLocaleString('es-CO')), 40, y);
      doc.text(cleanText('Archivo fuente: ' + (window.__lastCsvName || 'Datos cargados')), 40, y + 16);

      const headers = Object.keys(rawData[0] || {});
      schema = inferSchema(headers, rawData);
      const FIXED_STATE_COL = 'Estado Final Incidente';
      const colEstado = headers.indexOf(FIXED_STATE_COL) >= 0 ? FIXED_STATE_COL : (schema.roles.estado || null);
      const totalIncidentes = rawData.length;
      const openClosed = colEstado ? getOpenClosedTotals(rawData, colEstado) : { abiertos: 0, cerrados: 0 };
      const colTiempo = schema.roles.tiempo;
      var promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(function (r) { return parseNumber(r[colTiempo]); }).filter(function (n) { return !isNaN(n); });
        if (tiempos.length) promedioTiempo = average(tiempos);
      }
      y = addTable(
        doc,
        ['M√©trica', 'Valor', 'Interpretaci√≥n'],
        [
          ['Total de Incidentes', fmtInt(totalIncidentes), (totalIncidentes > 0 ? 'Carga activa' : 'Sin carga')],
          ['Incidentes Abiertos', fmtInt(openClosed.abiertos), (openClosed.abiertos > openClosed.cerrados ? 'Requiere atenci√≥n' : 'Bajo control')],
          ['Incidentes Cerrados', fmtInt(openClosed.cerrados), (openClosed.cerrados >= openClosed.abiertos ? 'Buena resoluci√≥n' : 'Mejorar cierre')],
          ['Tiempo Promedio (d√≠as)', fmtInt(promedioTiempo), (promedioTiempo > 30 ? 'Ciclo lento' : 'Ciclo adecuado')],
          ['Tasa de Resoluci√≥n', String(fmtInt((openClosed.cerrados / Math.max(1, totalIncidentes)) * 100)) + '%', 'Efectividad del equipo']
        ],
        y + 30,
        { 0: { cellWidth: 180 }, 1: { cellWidth: 80 }, 2: { cellWidth: 220 } }
      );

      // Narrativa ejecutiva (Camino A, sin LLM)
      const narrative = buildExecutiveNarrative(rawData, schema);
      addExecutiveInsightsToPdf(doc, narrative, y + 16);

      // *** Camino B: intentar a√±adir Narrativa (LLM) ***
      const payloadKPI = buildKpiPayload(schema, headers);
      const llmText = await getLLMExecutiveSummary(payloadKPI);
      addLLMPageToPdf(doc, llmText);

      // Resto de secciones (Estado / Responsables / Servicio / Proveedores / Categor√≠a / Tiempo) como antes‚Ä¶
      if (colEstado) {
        const t = getOpenClosedReturnedEmptyTotals(rawData, colEstado);
        const estadoPairs = [
          { label: 'Abiertos (' + t.abiertos + ')', value: t.abiertos },
          { label: 'Cerrados (' + t.cerrados + ')', value: t.cerrados },
          { label: 'Devuelto (' + t.devuelto + ')', value: t.devuelto },
          { label: 'Vac√≠os (' + t.vacios + ')', value: t.vacios }
        ];
        addLandscapePage(doc);
        y = drawHeader(doc, 'Estado ‚Äî Distribuci√≥n (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        addTable(doc, ['Estado', 'Casos', '% del total'], buildCountTableRows(estadoPairs), y,
          { 0: { cellWidth: 200 }, 1: { cellWidth: 80 }, 2: { cellWidth: 100 } }
        );
        addLandscapePage(doc);
        y = drawHeader(doc, 'Estado ‚Äî Distribuci√≥n (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartEstado', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const FIXED_RESP_COL = 'Ingeniero Asignado';
      const colResp = headers.indexOf(FIXED_RESP_COL) >= 0 ? FIXED_RESP_COL : (schema.roles.responsable || null);
      if (colResp && colEstado) {
        const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
        addLandscapePage(doc);
        y = drawHeader(doc, 'Responsables ‚Äî Abiertos vs Cerrados (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        addTable(doc, ['Responsable', 'Abiertos', '% fila', 'Cerrados', '% fila', 'Total'], buildResponsablesTableRows(rowsResp), y,
          { 0: { cellWidth: 200 }, 1: { cellWidth: 80 }, 2: { cellWidth: 80 }, 3: { cellWidth: 80 }, 4: { cellWidth: 80 }, 5: { cellWidth: 80 } }
        );
        addLandscapePage(doc);
        y = drawHeader(doc, 'Responsables ‚Äî Abiertos vs Cerrados (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartResponsables', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const colServ = schema.roles.servicio;
      if (colServ) {
        const countsServ = countBy(rawData, colServ).map(function (d) { return { label: cleanText(d.label), value: Math.round(d.value) }; });
        addLandscapePage(doc);
        y = drawHeader(doc, 'Tipificaci√≥n por Servicio (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        addTable(doc, ['Servicio', 'Casos', '% del total'], buildServicioTableRows(countsServ), y,
          { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 100 } }
        );
        addLandscapePage(doc);
        y = drawHeader(doc, 'Tipificaci√≥n por Servicio (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartServicio', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const FIXED_PROV_COL = 'Proveedor a escalar';
      const colProv = headers.indexOf(FIXED_PROV_COL) >= 0 ? FIXED_PROV_COL : (schema.roles.proveedor || null);
      if (colProv && colEstado) {
        const rowsProv = getOpenClosedByProvider(rawData, colProv, colEstado);
        addLandscapePage(doc);
        y = drawHeader(doc, 'Proveedores ‚Äî Abiertos vs Cerrados (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        addTable(doc, ['Proveedor', 'Abiertos', '% fila', 'Cerrados', '% fila', 'Total'], buildABvsCTableRows(rowsProv), y,
          { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 80 }, 3: { cellWidth: 80 }, 4: { cellWidth: 80 }, 5: { cellWidth: 80 } }
        );
        addLandscapePage(doc);
        y = drawHeader(doc, 'Proveedores ‚Äî Abiertos vs Cerrados (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartProveedor', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const FIXED_CAT_COL = 'Categor√≠a';
      const colCat = headers.indexOf(FIXED_CAT_COL) >= 0 ? FIXED_CAT_COL : (headers.find(function (h) { return /categor[i√≠]a/i.test(h); }) || null);
      if (colCat && colEstado) {
        const rowsCat = getOpenClosedByCategory(rawData, colCat, colEstado);
        addLandscapePage(doc);
        y = drawHeader(doc, 'Categor√≠a ‚Äî Abiertos vs Cerrados (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        addTable(doc, ['Categor√≠a', 'Abiertos', '% fila', 'Cerrados', '% fila', 'Total'], buildABvsCTableRows(rowsCat), y,
          { 0: { cellWidth: 220 }, 1: { cellWidth: 80 }, 2: { cellWidth: 80 }, 3: { cellWidth: 80 }, 4: { cellWidth: 80 }, 5: { cellWidth: 80 } }
        );
        addLandscapePage(doc);
        y = drawHeader(doc, 'Categor√≠a ‚Äî Abiertos vs Cerrados (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartCategoria', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const colTiempoPDF = schema.roles.tiempo;
      if (colTiempoPDF && colEstado) {
        const colRango = schema.roles.rangoEdad || headers.find(function (h) { return /rango\s*\_?\s*edad/i.test(h); });
        addLandscapePage(doc);
        y = drawHeader(doc, 'Tiempo Tickets (Promedio) ‚Äî Abiertos vs Cerrados (Tabla)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        if (colRango) {
          const rowsT = getAvgTimeByRangeAndState(rawData, colRango, colTiempoPDF, colEstado);
          addTable(doc, ['Rango', 'Prom. Abiertos (d√≠as)', '% fila', 'Prom. Cerrados (d√≠as)', '% fila', 'Casos fila'], buildTiempoTableRows(rowsT, false), y,
            { 0: { cellWidth: 180 }, 1: { cellWidth: 120 }, 2: { cellWidth: 80 }, 3: { cellWidth: 120 }, 4: { cellWidth: 80 }, 5: { cellWidth: 80 } }
          );
        } else {
          const g = getAvgTimeByStateGlobal(rawData, colTiempoPDF, colEstado);
          addTable(doc, ['Rango', 'Prom. Abiertos (d√≠as)', '% fila', 'Prom. Cerrados (d√≠as)', '% fila', 'Casos fila'], buildTiempoTableRows(g, true), y,
            { 0: { cellWidth: 180 }, 1: { cellWidth: 120 }, 2: { cellWidth: 80 }, 3: { cellWidth: 120 }, 4: { cellWidth: 80 }, 5: { cellWidth: 80 } }
          );
        }
        addLandscapePage(doc);
        y = drawHeader(doc, 'Tiempo Tickets (Promedio) ‚Äî Abiertos vs Cerrados (Gr√°fico)', { bg: COLOR_BG, text: { r: 255, g: 255, b: 255 } });
        applyPrintTheme(true);
        const graphLeft = 40, graphTop = y;
        const maxWidth = Math.floor(pageWidth - 80);
        const maxHeight = Math.floor(pageHeight - (y + 40));
        const w16_9 = maxWidth;
        const h16_9 = Math.min(maxHeight, Math.floor(w16_9 * 9 / 16));
        const canvasHD = getCanvasForPdfHD('chartTiempo', w16_9, h16_9, 3);
        if (canvasHD) doc.addImage(canvasHD.toDataURL('image/png', 1.0), 'PNG', graphLeft, graphTop, w16_9, h16_9);
        applyPrintTheme(false);
      }

      const totalPages = doc.internal.getNumberOfPages();
      for (var i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        const pw = doc.internal.pageSize.getWidth();
        const ph = doc.internal.pageSize.getHeight();
        doc.setFontSize(9);
        doc.setTextColor(120);
        doc.text(cleanText('P√°gina ' + i + ' de ' + totalPages + ' ‚Äî Dashboard Incidentes TI'), pw / 2, ph - 30, { align: 'center' });
        doc.text(cleanText('John Jairo Vargas Gonz√°lez ‚Äî Ingeniero de Soluciones TI ‚Äî john.vargas@bancounion.com'), pw / 2, ph - 16, { align: 'center' });
      }
      const nombreArchivo = 'Reporte_Ejecutivo_Incidentes_' + new Date().toISOString().slice(0, 10) + '.pdf';
      doc.save(nombreArchivo);
    }

    /* ===================== Exportaci√≥n Excel ===================== */
    function generateExcelReport() {
      if (!rawData.length) {
        alert('No hay datos cargados. Por favor carga un archivo CSV primero.');
        return;
      }
      const wb = XLSX.utils.book_new();
      const totalIncidentes = rawData.length;
      const headers = Object.keys(rawData[0] || {});
      schema = inferSchema(headers, rawData);
      const colEstado = (schema && schema.roles && schema.roles.estado) ? schema.roles.estado : 'Estado Final Incidente';
      const openClosed = getOpenClosedTotals(rawData, colEstado);
      const colTiempo = (schema && schema.roles && schema.roles.tiempo) ? schema.roles.tiempo : null;
      var promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(function (r) { return parseNumber(r[colTiempo]); }).filter(function (n) { return !isNaN(n); });
        if (tiempos.length) promedioTiempo = average(tiempos);
      }
      const resumenData = [
        ['REPORTE EJECUTIVO - BACKLOG INCIDENTES TI'],
        ['Fecha de Generaci√≥n:', new Date().toLocaleString('es-CO')],
        ['Archivo Fuente:', cleanText(window.__lastCsvName || 'Datos cargados')],
        [''],
        ['M√âTRICAS PRINCIPALES'],
        ['M√©trica', 'Valor', 'Notas'],
        ['Total de Incidentes', Math.round(totalIncidentes), totalIncidentes > 0 ? 'Carga activa' : 'Sin carga'],
        ['Incidentes Abiertos', Math.round(openClosed.abiertos), openClosed.abiertos > openClosed.cerrados ? 'Requiere atenci√≥n' : 'Bajo control'],
        ['Incidentes Cerrados', Math.round(openClosed.cerrados), openClosed.cerrados >= openClosed.abiertos ? 'Buena resoluci√≥n' : 'Mejorar cierre'],
        ['Tiempo Promedio (d√≠as)', Math.round(Number(promedioTiempo)), promedioTiempo > 30 ? 'Ciclo lento' : 'Ciclo adecuado'],
        ['Tasa de Resoluci√≥n', String(Math.round((openClosed.cerrados / Math.max(1, totalIncidentes)) * 100)) + '%', 'Efectividad del equipo']
      ];
      const wsResumen = XLSX.utils.aoa_to_sheet(resumenData);
      wsResumen['!cols'] = [{ wch: 32 }, { wch: 24 }, { wch: 44 }];
      wsResumen['!freeze'] = { rows: 1, cols: 0 };
      XLSX.utils.book_append_sheet(wb, wsResumen, 'Resumen Ejecutivo');

      const wsData = XLSX.utils.json_to_sheet(rawData);
      const colsKeys = Object.keys(rawData[0] || {});
      wsData['!cols'] = colsKeys.map(function (k) { return { wch: Math.min(30, Math.max(10, k.length + 6)) }; });
      wsData['!freeze'] = { rows: 1, cols: 0 };
      XLSX.utils.book_append_sheet(wb, wsData, 'Datos Completos');

      // Hoja ‚ÄúHallazgos‚Äù ‚Äî narrativa sin LLM
      const narrative = buildExecutiveNarrative(rawData, schema);
      const sheetHallazgos = [
        ['HALLAZGOS Y ACCIONES'],
        ['Resumen Ejecutivo'],
        ...narrative.resumen.map(line => [cleanText(line)]),
        [''],
        ['Riesgos/Se√±ales'],
        ...narrative.riesgos.map(line => ['‚Ä¢ ' + cleanText(line)]),
        [''],
        ['Acciones recomendadas (30 d√≠as)'],
        ...narrative.acciones.map(line => ['‚Ä¢ ' + cleanText(line)]),
        [''],
        ['Top-5 Responsables (por abiertos)'],
        ['Responsable', 'Abiertos', 'Cerrados', 'Total'],
        ...narrative.topRespAbiertos.map(r => [cleanText(r.label), fmtInt(r.abiertos), fmtInt(r.cerrados), fmtInt(r.total)]),
        [''],
        ['Top-5 Proveedores (por abiertos)'],
        ['Proveedor', 'Abiertos', 'Cerrados', 'Total'],
        ...narrative.topProvAbiertos.map(r => [cleanText(r.label), fmtInt(r.abiertos), fmtInt(r.cerrados), fmtInt(r.total)]),
        [''],
        ['Top-5 Servicios (por casos)'],
        ['Servicio', 'Casos', '% del total'],
        ...buildCountTableRows(narrative.topServicios.map(s => ({ label: s.label, value: s.value })))
      ];
      const wsHall = XLSX.utils.aoa_to_sheet(sheetHallazgos);
      wsHall['!cols'] = [{ wch: 40 }, { wch: 20 }, { wch: 20 }, { wch: 20 }];
      wsHall['!freeze'] = { rows: 1, cols: 0 };
      XLSX.utils.book_append_sheet(wb, wsHall, 'Hallazgos');

      // *** NUEVO: Hoja Narrativa (LLM) si disponible ***
      (async () => {
        if (LLM_ENABLED) {
          const payloadKPI = buildKpiPayload(schema, headers);
          const llmText = await getLLMExecutiveSummary(payloadKPI);
          if (llmText) {
            const lines = llmText.split('\n').map(s => [cleanText(s)]);
            const wsLLM = XLSX.utils.aoa_to_sheet([['NARRATIVA (LLM)'], ...lines]);
            wsLLM['!cols'] = [{ wch: 96 }];
            XLSX.utils.book_append_sheet(wb, wsLLM, 'Narrativa (LLM)');
          }
        }
        const nombreArchivo = 'Reporte_Detallado_Incidentes_' + new Date().toISOString().slice(0, 10) + '.xlsx';
        XLSX.writeFile(wb, nombreArchivo);
      })();
    }

    /* ===================== Mask plugins (ocultan % al ocultar datasets) ===================== */
    const PercentVisibilityMaskPlugin = {
      id: 'percentVisibilityMask',
      beforeDatasetsDraw: function (chart) {
        try {
          if (!chart.canvas || chart.canvas.id !== 'chartResponsables') return;
          const cfg = chart.options && chart.options.plugins ? chart.options.plugins.perBarPercentLabels : null;
          if (!cfg || !cfg.mapping || typeof cfg.mapping !== 'object') return;
          if (!chart.$percentMappingOriginal) {
            const orig = {};
            Object.keys(cfg.mapping).forEach(function (k) {
              const arr = cfg.mapping[k];
              orig[k] = Array.isArray(arr) ? arr.slice() : arr;
            });
            chart.$percentMappingOriginal = orig;
          }
          const restored = {};
          Object.keys(chart.$percentMappingOriginal).forEach(function (k) {
            const arr = chart.$percentMappingOriginal[k];
            restored[k] = Array.isArray(arr) ? arr.slice() : arr;
          });
          const masked = {};
          Object.keys(restored).forEach(function (key) {
            const dsIndex = Number(key);
            const meta = chart.getDatasetMeta(dsIndex);
            const isVisible = (typeof chart.isDatasetVisible === 'function')
              ? chart.isDatasetVisible(dsIndex)
              : !(meta && meta.hidden === true);
            masked[dsIndex] = isVisible ? restored[dsIndex] : [];
          });
          chart.options.plugins.perBarPercentLabels.mapping = masked;
        } catch (e) { console.warn('PercentVisibilityMaskPlugin error:', e); }
      }
    };
    const PercentVisibilityMaskPluginCat = {
      id: 'percentVisibilityMaskCat',
      beforeDatasetsDraw: function (chart) {
        try {
          if (!chart.canvas || chart.canvas.id !== 'chartCategoria') return;
          const cfg = chart.options && chart.options.plugins ? chart.options.plugins.perBarPercentLabelsCat : null;
          if (!cfg || !cfg.mapping || typeof cfg.mapping !== 'object') return;
          if (!chart.$percentMappingOriginalCat) {
            const orig = {};
            Object.keys(cfg.mapping).forEach(function (k) {
              const arr = cfg.mapping[k];
              orig[k] = Array.isArray(arr) ? arr.slice() : arr;
            });
            chart.$percentMappingOriginalCat = orig;
          }
          const restored = {};
          Object.keys(chart.$percentMappingOriginalCat).forEach(function (k) {
            const arr = chart.$percentMappingOriginalCat[k];
            restored[k] = Array.isArray(arr) ? arr.slice() : arr;
          });
          const masked = {};
          Object.keys(restored).forEach(function (key) {
            const dsIndex = Number(key);
            const meta = chart.getDatasetMeta(dsIndex);
            const isVisible = (typeof chart.isDatasetVisible === 'function')
              ? chart.isDatasetVisible(dsIndex)
              : !(meta && meta.hidden === true);
            masked[dsIndex] = isVisible ? restored[dsIndex] : [];
          });
          chart.options.plugins.perBarPercentLabelsCat.mapping = masked;
        } catch (e) { console.warn('PercentVisibilityMaskPluginCat error:', e); }
      }
    };
    const PercentVisibilityMaskPluginProv = {
      id: 'percentVisibilityMaskProv',
      beforeDatasetsDraw: function (chart) {
        try {
          if (!chart.canvas || chart.canvas.id !== 'chartProveedor') return;
          const cfg = chart.options && chart.options.plugins ? chart.options.plugins.perBarPercentLabelsProv : null;
          if (!cfg || !cfg.mapping || typeof cfg.mapping !== 'object') return;
          if (!chart.$percentMappingOriginalProv) {
            const orig = {};
            Object.keys(cfg.mapping).forEach(function (k) {
              const arr = cfg.mapping[k];
              orig[k] = Array.isArray(arr) ? arr.slice() : arr;
            });
            chart.$percentMappingOriginalProv = orig;
          }
          const restored = {};
          Object.keys(chart.$percentMappingOriginalProv).forEach(function (k) {
            const arr = chart.$percentMappingOriginalProv[k];
            restored[k] = Array.isArray(arr) ? arr.slice() : arr;
          });
          const masked = {};
          Object.keys(restored).forEach(function (key) {
            const dsIndex = Number(key);
            const meta = chart.getDatasetMeta(dsIndex);
            const isVisible = (typeof chart.isDatasetVisible === 'function')
              ? chart.isDatasetVisible(dsIndex)
              : !(meta && meta.hidden === true);
            masked[dsIndex] = isVisible ? restored[dsIndex] : [];
          });
          chart.options.plugins.perBarPercentLabelsProv.mapping = masked;
        } catch (e) { console.warn('PercentVisibilityMaskPluginProv error:', e); }
      }
    };
    const PercentVisibilityMaskPluginTime = {
      id: 'percentVisibilityMaskTime',
      beforeDatasetsDraw: function (chart) {
        try {
          if (!chart.canvas || chart.canvas.id !== 'chartTiempo') return;
          const cfg = chart.options && chart.options.plugins ? chart.options.plugins.perBarPercentLabelsTime : null;
          if (!cfg || !cfg.mapping || typeof cfg.mapping !== 'object') return;
          if (!chart.$percentMappingOriginalTime) {
            const orig = {};
            Object.keys(cfg.mapping).forEach(function (k) {
              const arr = cfg.mapping[k];
              orig[k] = Array.isArray(arr) ? arr.slice() : arr;
            });
            chart.$percentMappingOriginalTime = orig;
          }
          const restored = {};
          Object.keys(chart.$percentMappingOriginalTime).forEach(function (k) {
            const arr = chart.$percentMappingOriginalTime[k];
            restored[k] = Array.isArray(arr) ? arr.slice() : arr;
          });
          const masked = {};
          Object.keys(restored).forEach(function (key) {
            const dsIndex = Number(key);
            const meta = chart.getDatasetMeta(dsIndex);
            const isVisible = (typeof chart.isDatasetVisible === 'function')
              ? chart.isDatasetVisible(dsIndex)
              : !(meta && meta.hidden === true);
            masked[dsIndex] = isVisible ? restored[dsIndex] : [];
          });
          chart.options.plugins.perBarPercentLabelsTime.mapping = masked;
        } catch (e) { console.warn('PercentVisibilityMaskPluginTime error:', e); }
      }
    };
    const PercentVisibilityMaskPluginServ = {
      id: 'percentVisibilityMaskServ',
      beforeDatasetsDraw: function (chart) {
        try {
          if (!chart.canvas || chart.canvas.id !== 'chartServicio') return;
          const cfg = chart.options && chart.options.plugins ? chart.options.plugins.perBarPercentLabelsServ : null;
          if (!cfg || !cfg.mapping || typeof cfg.mapping !== 'object') return;
          if (!chart.$percentMappingOriginalServ) {
            const orig = {};
            Object.keys(cfg.mapping).forEach(function (k) {
              const arr = cfg.mapping[k];
              orig[k] = Array.isArray(arr) ? arr.slice() : arr;
            });
            chart.$percentMappingOriginalServ = orig;
          }
          const restored = {};
          Object.keys(chart.$percentMappingOriginalServ).forEach(function (k) {
            const arr = chart.$percentMappingOriginalServ[k];
            restored[k] = Array.isArray(arr) ? arr.slice() : arr;
          });
          const masked = {};
          Object.keys(restored).forEach(function (key) {
            const dsIndex = Number(key);
            const meta = chart.getDatasetMeta(dsIndex);
            const isVisible = (typeof chart.isDatasetVisible === 'function')
              ? chart.isDatasetVisible(dsIndex)
              : !(meta && meta.hidden === true);
            masked[dsIndex] = isVisible ? restored[dsIndex] : [];
          });
          chart.options.plugins.perBarPercentLabelsServ.mapping = masked;
        } catch (e) { console.warn('PercentVisibilityMaskPluginServ error:', e); }
      }
    };
    Chart.register(PercentVisibilityMaskPlugin);
    Chart.register(PercentVisibilityMaskPluginCat);
    Chart.register(PercentVisibilityMaskPluginProv);
    Chart.register(PercentVisibilityMaskPluginTime);
    Chart.register(PercentVisibilityMaskPlugin);


    /* ===================== OVERRIDE: SISTEMA DE REPORTES MEJORADO ===================== */
    /*  Este bloque se apoya en las utilidades ya presentes en app.js:
        - rawData, schema, inferSchema, countBy, average, parseNumber, cleanText
        - getOpenClosedReturnedEmptyTotals, getOpenClosedByResponsible, getOpenClosedByProvider, getOpenClosedByCategory
        - getLogoDataUrl, getCanvasForPdfHD, applyPrintTheme
        No elimines el c√≥digo original: este bloque solo sobreescribe los exports PDF/Excel.
    */

    /* ==================== PDF EJECUTIVO MODERNO (Portrait A4) ==================== */
    async function generateModernPDFReport() {
      if (!rawData.length) { alert('No hay datos cargados. Por favor carga un archivo CSV primero.'); return; }
      // Mostrar indicador de carga
      showLoadingIndicator('Generando PDF profesional...');

      try {
        const jsPDFlib = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : window.jsPDF;
        if (!jsPDFlib) { throw new Error('jsPDF no est√° disponible'); }

        const doc = new jsPDFlib('portrait', 'mm', 'a4');
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();

        // Paleta moderna
        const colors = {
          primary: [76, 201, 240],    // Cyan brillante
          secondary: [67, 97, 238],   // Azul profundo
          dark: [15, 23, 42],         // Azul oscuro
          accent: [231, 111, 81],     // Naranja
          success: [42, 157, 143],    // Verde agua
          warning: [255, 190, 11],    // Amarillo
          text: [30, 30, 30],         // Negro suave
          lightGray: [245, 247, 250]  // Gris claro
        };

        /* ============ PORTADA MODERNA ============ */
        drawModernCover(doc, colors, pageWidth, pageHeight);

        /* ============ √çNDICE ============ */
        doc.addPage();
        drawTableOfContents(doc, colors, pageWidth);

        /* ============ RESUMEN EJECUTIVO ============ */
        doc.addPage();
        await drawExecutiveSummary(doc, colors, pageWidth);

        /* ============ M√âTRICAS CLAVE ============ */
        doc.addPage();
        await drawKeyMetrics(doc, colors, pageWidth);

        /* ============ AN√ÅLISIS POR ESTADO ============ */
        doc.addPage();
        await drawStateAnalysis(doc, colors, pageWidth, pageHeight);

        /* ============ AN√ÅLISIS POR RESPONSABLE ============ */
        doc.addPage();
        await drawResponsibleAnalysis(doc, colors, pageWidth, pageHeight);

        /* ============ AN√ÅLISIS POR SERVICIO ============ */
        doc.addPage();
        await drawServiceAnalysis(doc, colors, pageWidth, pageHeight);

        /* ============ TIEMPO Y RENDIMIENTO ============ */
        doc.addPage();
        await drawTimeAnalysis(doc, colors, pageWidth, pageHeight);

        /* ============ RECOMENDACIONES ============ */
        doc.addPage();
        drawRecommendations(doc, colors, pageWidth);

        /* ============ PIE DE P√ÅGINA EN TODAS LAS P√ÅGINAS ============ */
        addModernFooters(doc, colors, pageWidth, pageHeight);

        // Guardar
        const fileName = `Dashboard_Ejecutivo_${new Date().toISOString().slice(0, 10)}.pdf`;
        doc.save(fileName);

        hideLoadingIndicator();
        showSuccessNotification('PDF generado exitosamente');
      } catch (err) {
        console.error('Error generando PDF:', err);
        hideLoadingIndicator();
        showErrorNotification('Error al generar el PDF: ' + err.message);
      }
    }

    /* ==================== FUNCIONES DE DISE√ëO PDF ==================== */
    function drawModernCover(doc, colors, pageWidth, pageHeight) {
      // Fondo con gradiente simulado
      doc.setFillColor(...colors.dark);
      doc.rect(0, 0, pageWidth, pageHeight, 'F');

      // Banda superior
      doc.setFillColor(...colors.primary);
      doc.rect(0, 0, pageWidth, 60, 'F');

      // Banda diagonal
      doc.setFillColor(...colors.secondary);
      doc.triangle(0, 60, pageWidth, 60, pageWidth, 90, 'F');

      // Logo (si existe)
      try {
        const logo = getLogoDataUrl();
        if (logo) doc.addImage(logo, 'PNG', 20, 10, 60, 40);
      } catch (e) { console.warn('No se pudo cargar el logo'); }

      // T√≠tulos
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(32);
      doc.text('Dashboard Ejecutivo', pageWidth / 2, 120, { align: 'center' });
      doc.setFontSize(24);
      doc.text('Backlog Incidentes TI', pageWidth / 2, 135, { align: 'center' });

      doc.setFont('helvetica', 'normal'); doc.setFontSize(14);
      doc.setTextColor(200, 200, 200);
      doc.text('An√°lisis y M√©tricas de Gesti√≥n', pageWidth / 2, 150, { align: 'center' });

      // Info reporte
      doc.setFontSize(11); doc.setTextColor(180, 180, 180);
      const fecha = new Date().toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });
      doc.text(`Fecha de generaci√≥n: ${fecha}`, pageWidth / 2, 180, { align: 'center' });
      doc.text(`Total de registros: ${rawData.length}`, pageWidth / 2, 190, { align: 'center' });

      // Caja info
      doc.setFillColor(...colors.secondary);
      doc.roundedRect(40, 210, pageWidth - 80, 40, 3, 3, 'F');
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(10);
      doc.text('CONFIDENCIAL - USO INTERNO', pageWidth / 2, 225, { align: 'center' });
      doc.setFont('helvetica', 'normal'); doc.setFontSize(9);
      doc.text('Este documento contiene informaci√≥n sensible de la organizaci√≥n', pageWidth / 2, 235, { align: 'center' });

      // Pie portada
      doc.setFontSize(8); doc.setTextColor(150, 150, 150);
      doc.text('John Jairo Vargas Gonz√°lez - Ingeniero de Soluciones TI', pageWidth / 2, pageHeight - 20, { align: 'center' });
      doc.text('john.vargas@bancounion.com', pageWidth / 2, pageHeight - 15, { align: 'center' });
    }

    function drawTableOfContents(doc, colors, pageWidth) {
      let y = 30;
      // T√≠tulo
      doc.setFillColor(...colors.secondary);
      doc.rect(0, y - 10, pageWidth, 15, 'F');
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(18);
      doc.text('√çndice de Contenidos', 20, y); y += 25;

      const sections = [
        { title: '1. Resumen Ejecutivo', page: 3 },
        { title: '2. M√©tricas Clave', page: 4 },
        { title: '3. An√°lisis por Estado', page: 5 },
        { title: '4. An√°lisis por Responsable', page: 6 },
        { title: '5. An√°lisis por Servicio', page: 7 },
        { title: '6. Tiempo y Rendimiento', page: 8 },
        { title: '7. Recomendaciones', page: 9 }
      ];

      doc.setTextColor(...colors.text);
      doc.setFont('helvetica', 'normal'); doc.setFontSize(12);
      sections.forEach(section => {
        doc.setFillColor(...colors.primary);
        doc.circle(25, y - 2, 2, 'F');
        doc.text(section.title, 35, y);

        doc.setDrawColor(200, 200, 200);
        doc.setLineDash([1, 2]);
        doc.line(120, y, pageWidth - 40, y);
        doc.setLineDash([]);

        doc.setFont('helvetica', 'bold');
        doc.text(String(section.page), pageWidth - 30, y);
        doc.setFont('helvetica', 'normal');

        y += 12;
      });
    }

    async function drawExecutiveSummary(doc, colors, pageWidth) {
      let y = 30;
      drawSectionHeader(doc, colors, 'Resumen Ejecutivo', pageWidth, y); y += 20;

      const headers = Object.keys(rawData[0] || {});
      schema = inferSchema(headers, rawData);

      const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : schema.roles?.estado;
      const totals = getOpenClosedReturnedEmptyTotals(rawData, colEstado);
      const tasaResolucion = ((totals.cerrados / totals.total) * 100).toFixed(1);

      const colTiempo = schema.roles?.tiempo;
      let promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        promedioTiempo = tiempos.length ? average(tiempos) : 0;
      }

      const metrics = [
        { label: 'Total Incidentes', value: totals.total, color: colors.primary, icon: 'üìä' },
        { label: 'Tasa Resoluci√≥n', value: `${tasaResolucion}%`, color: colors.success, icon: '‚úì' },
        { label: 'Tiempo Promedio', value: `${Math.round(promedioTiempo)} d√≠as`, color: colors.warning, icon: '‚è±' },
        { label: 'Backlog Actual', value: totals.abiertos, color: colors.accent, icon: '‚ö†' }
      ];

      const cardWidth = (pageWidth - 60) / 2;
      const cardHeight = 30;
      let x = 20;

      metrics.forEach((metric, i) => {
        if (i % 2 === 0 && i > 0) { y += cardHeight + 10; x = 20; }

        doc.setFillColor(...metric.color);
        doc.roundedRect(x, y, cardWidth, cardHeight, 3, 3, 'F');

        doc.setTextColor(255, 255, 255);
        doc.setFontSize(10); doc.setFont('helvetica', 'normal');
        doc.text(metric.icon + ' ' + metric.label, x + 5, y + 10);

        doc.setFontSize(20); doc.setFont('helvetica', 'bold');
        doc.text(String(metric.value), x + 5, y + 24);

        x += cardWidth + 10;
      });

      y += cardHeight + 20;

      doc.setFillColor(...colors.lightGray);
      doc.roundedRect(20, y, pageWidth - 40, 80, 3, 3, 'F');

      doc.setTextColor(...colors.text);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(12);
      doc.text('An√°lisis de Situaci√≥n', 25, y + 10);

      doc.setFont('helvetica', 'normal'); doc.setFontSize(10);
      const narrative = buildExecutiveNarrative(rawData, schema); // Camino A (sin LLM)
      let textY = y + 20;
      narrative.resumen.slice(0, 5).forEach(line => {
        const wrapped = doc.splitTextToSize(cleanText(line), pageWidth - 50);
        doc.text(wrapped, 25, textY);
        textY += wrapped.length * 5;
      });
    }

    async function drawKeyMetrics(doc, colors, pageWidth) {
      let y = 30;
      drawSectionHeader(doc, colors, 'M√©tricas Clave de Rendimiento', pageWidth, y); y += 20;

      const headers = Object.keys(rawData[0] || {});
      schema = inferSchema(headers, rawData);
      const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : schema.roles?.estado;
      const totals = getOpenClosedReturnedEmptyTotals(rawData, colEstado);

      const metricsData = [
        ['M√©trica', 'Valor', 'Interpretaci√≥n', 'Estado'],
        ['Incidentes Abiertos', String(totals.abiertos), `${((totals.abiertos / totals.total) * 100).toFixed(1)}% del total`, totals.abiertos > totals.cerrados ? '‚ö† Alto' : '‚úì Normal'],
        ['Incidentes Cerrados', String(totals.cerrados), `${((totals.cerrados / totals.total) * 100).toFixed(1)}% del total`, totals.cerrados >= totals.abiertos ? '‚úì Bueno' : '‚ö† Mejorar'],
        ['Casos Devueltos', String(totals.devuelto), `${((totals.devuelto / totals.total) * 100).toFixed(1)}% del total`, totals.devuelto > 0 ? '‚ö† Revisar' : '‚úì OK'],
        ['Registros Vac√≠os', String(totals.vacios), 'Requiere validaci√≥n de datos', totals.vacios > 0 ? '‚ö† Acci√≥n requerida' : '‚úì OK']
      ];

      doc.autoTable({
        startY: y,
        head: [metricsData[0]],
        body: metricsData.slice(1),
        theme: 'grid',
        headStyles: { fillColor: colors.secondary, textColor: [255, 255, 255], fontStyle: 'bold', halign: 'center', fontSize: 10 },
        styles: { fontSize: 9, cellPadding: 5 },
        columnStyles: { 0: { cellWidth: 45, fontStyle: 'bold' }, 1: { cellWidth: 30, halign: 'center' }, 2: { cellWidth: 60 }, 3: { cellWidth: 35, halign: 'center', fontStyle: 'bold' } },
        alternateRowStyles: { fillColor: colors.lightGray }
      });

      y = doc.lastAutoTable.finalY + 15;
      await embedChartInPDF(doc, 'chartEstado', 20, y, pageWidth - 40, 80);
    }

    async function drawStateAnalysis(doc, colors, pageWidth, pageHeight) {
      let y = 30;
      drawSectionHeader(doc, colors, 'An√°lisis por Estado', pageWidth, y); y += 20;

      const headers = Object.keys(rawData[0] || {});
      const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : schema?.roles?.estado;

      if (colEstado) {
        const totals = getOpenClosedReturnedEmptyTotals(rawData, colEstado);
        const stateData = [
          ['Estado', 'Cantidad', '% del Total'],
          ['Abiertos', String(totals.abiertos), `${((totals.abiertos / totals.total) * 100).toFixed(1)}%`],
          ['Cerrados', String(totals.cerrados), `${((totals.cerrados / totals.total) * 100).toFixed(1)}%`],
          ['Devueltos', String(totals.devuelto), `${((totals.devuelto / totals.total) * 100).toFixed(1)}%`],
          ['Vac√≠os', String(totals.vacios), `${((totals.vacios / totals.total) * 100).toFixed(1)}%`],
          ['TOTAL', String(totals.total), '100%']
        ];

        doc.autoTable({
          startY: y,
          head: [stateData[0]],
          body: stateData.slice(1, -1),
          foot: [stateData[stateData.length - 1]],
          theme: 'grid',
          headStyles: { fillColor: colors.secondary, textColor: [255, 255, 255], fontStyle: 'bold', halign: 'center' },
          footStyles: { fillColor: colors.primary, textColor: [255, 255, 255], fontStyle: 'bold', halign: 'center' },
          columnStyles: { 0: { cellWidth: 60, fontStyle: 'bold' }, 1: { cellWidth: 50, halign: 'center' }, 2: { cellWidth: 50, halign: 'center' } }
        });

        y = doc.lastAutoTable.finalY + 15;
        await embedChartInPDF(doc, 'chartEstado', 20, y, pageWidth - 40, 100);
      }
    }

    async function drawResponsibleAnalysis(doc, colors, pageWidth, pageHeight) {
      let y = 30;
      drawSectionHeader(doc, colors, 'An√°lisis por Responsable', pageWidth, y); y += 20;

      const headers = Object.keys(rawData[0] || {});
      const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : schema?.roles?.estado;
      const colResp = headers.includes('Ingeniero Asignado') ? 'Ingeniero Asignado' : schema?.roles?.responsable;

      if (colResp && colEstado) {
        const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
        const topResp = rowsResp.slice(0, 10);
        const tableData = [['Responsable', 'Abiertos', '% Fila', 'Cerrados', '% Fila', 'Total']];

        topResp.forEach(r => {
          const total = r.abiertos + r.cerrados;
          tableData.push([
            cleanText(r.label),
            String(r.abiertos),
            `${((r.abiertos / total) * 100).toFixed(1)}%`,
            String(r.cerrados),
            `${((r.cerrados / total) * 100).toFixed(1)}%`,
            String(total)
          ]);
        });

        doc.autoTable({
          startY: y, head: [tableData[0]], body: tableData.slice(1), theme: 'striped',
          headStyles: { fillColor: colors.secondary, textColor: [255, 255, 255], fontStyle: 'bold', halign: 'center', fontSize: 9 },
          styles: { fontSize: 8, cellPadding: 3 },
          columnStyles: { 0: { cellWidth: 70 }, 1: { cellWidth: 20, halign: 'center' }, 2: { cellWidth: 20, halign: 'center' }, 3: { cellWidth: 20, halign: 'center' }, 4: { cellWidth: 20, halign: 'center' }, 5: { cellWidth: 20, halign: 'center', fontStyle: 'bold' } }
        });

        y = doc.lastAutoTable.finalY + 10;
        await embedChartInPDF(doc, 'chartResponsables', 20, y, pageWidth - 40, 80);
      }
    }

    async function drawServiceAnalysis(doc, colors, pageWidth, pageHeight) {
      let y = 30;
      drawSectionHeader(doc, colors, 'An√°lisis por Servicio', pageWidth, y); y += 20;

      const colServ = schema?.roles?.servicio;
      if (colServ) {
        const counts = countBy(rawData, colServ);
        const total = counts.reduce((sum, c) => sum + c.value, 0);
        const topServices = counts.slice(0, 15);

        const tableData = [['Servicio', 'Cantidad', '% del Total']];
        topServices.forEach(s => {
          tableData.push([cleanText(s.label), String(Math.round(s.value)), `${((s.value / total) * 100).toFixed(1)}%`]);
        });

        doc.autoTable({
          startY: y,
          head: [tableData[0]],
          body: tableData.slice(1),
          theme: 'grid',
          headStyles: { fillColor: colors.secondary, textColor: [255, 255, 255], fontStyle: 'bold', halign: 'center' },
          columnStyles: { 0: { cellWidth: 100 }, 1: { cellWidth: 40, halign: 'center' }, 2: { cellWidth: 40, halign: 'center' } }
        });

        y = doc.lastAutoTable.finalY + 10;
        await embedChartInPDF(doc, 'chartServicio', 20, y, pageWidth - 40, 80);
      }
    }

    async function drawTimeAnalysis(doc, colors, pageWidth, pageHeight) {
      let y = 30;
      drawSectionHeader(doc, colors, 'An√°lisis de Tiempo y Rendimiento', pageWidth, y); y += 20;

      await embedChartInPDF(doc, 'chartTiempo', 20, y, pageWidth - 40, 100);
      y += 110;

      const colTiempo = schema?.roles?.tiempo;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        if (tiempos.length) {
          const promedio = average(tiempos);
          const max = Math.max(...tiempos);
          const min = Math.min(...tiempos);

          const timeMetrics = [
            ['M√©trica', 'Valor (d√≠as)'],
            ['Tiempo Promedio', String(Math.round(promedio))],
            ['Tiempo M√°ximo', String(Math.round(max))],
            ['Tiempo M√≠nimo', String(Math.round(min))]
          ];

          doc.autoTable({
            startY: y,
            head: [timeMetrics[0]],
            body: timeMetrics.slice(1),
            theme: 'grid',
            headStyles: { fillColor: colors.secondary, textColor: [255, 255, 255], fontStyle: 'bold' },
            columnStyles: { 0: { cellWidth: 80, fontStyle: 'bold' }, 1: { cellWidth: 60, halign: 'center', fontSize: 12 } }
          });
        }
      }
    }

    function drawRecommendations(doc, colors, pageWidth) {
      let y = 30;
      drawSectionHeader(doc, colors, 'Recomendaciones Estrat√©gicas', pageWidth, y); y += 20;

      const narrative = buildExecutiveNarrative(rawData, schema);

      doc.setFont('helvetica', 'bold'); doc.setFontSize(12); doc.setTextColor(...colors.accent);
      doc.text('‚ö† Riesgos Identificados', 20, y); y += 10;

      doc.setFont('helvetica', 'normal'); doc.setFontSize(10); doc.setTextColor(...colors.text);
      narrative.riesgos.forEach(riesgo => {
        const wrapped = doc.splitTextToSize('‚Ä¢ ' + cleanText(riesgo), pageWidth - 45);
        doc.text(wrapped, 25, y);
        y += wrapped.length * 6 + 3;
      });

      y += 10;
      doc.setFont('helvetica', 'bold'); doc.setFontSize(12); doc.setTextColor(...colors.success);
      doc.text('‚úì Acciones Recomendadas', 20, y); y += 10;

      doc.setFont('helvetica', 'normal'); doc.setFontSize(10); doc.setTextColor(...colors.text);
      narrative.acciones.forEach(accion => {
        const wrapped = doc.splitTextToSize('‚Ä¢ ' + cleanText(accion), pageWidth - 45);
        doc.text(wrapped, 25, y);
        y += wrapped.length * 6 + 3;
      });
    }

    function drawSectionHeader(doc, colors, title, pageWidth, y) {
      doc.setFillColor(...colors.primary);
      doc.rect(0, y - 5, pageWidth, 12, 'F');
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold'); doc.setFontSize(14);
      doc.text(title, 20, y + 4);
    }

    async function embedChartInPDF(doc, chartId, x, y, width, height) {
      try {
        applyPrintTheme(true);
        await new Promise(resolve => setTimeout(resolve, 100));
        const canvas = getCanvasForPdfHD(chartId, width * 3, height * 3, 3);
        if (canvas) doc.addImage(canvas.toDataURL('image/png', 1.0), 'PNG', x, y, width, height);
        applyPrintTheme(false);
      } catch (err) {
        console.error('Error embebiendo gr√°fico:', err);
      }
    }

    function addModernFooters(doc, colors, pageWidth, pageHeight) {
      const totalPages = doc.internal.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setDrawColor(...colors.primary); doc.setLineWidth(0.5);
        doc.line(20, pageHeight - 20, pageWidth - 20, pageHeight - 20);

        doc.setFontSize(8); doc.setTextColor(100, 100, 100); doc.setFont('helvetica', 'normal');
        const leftText = 'Dashboard Incidentes TI - Banco Uni√≥n';
        const centerText = `P√°gina ${i} de ${totalPages}`;
        const rightText = new Date().toLocaleDateString('es-CO');
        doc.text(leftText, 20, pageHeight - 10);
        doc.text(centerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.text(rightText, pageWidth - 20, pageHeight - 10, { align: 'right' });
      }
    }

    /* ==================== EXCEL PROFESIONAL MEJORADO ==================== */
    function generateModernExcelReport() {
      if (!rawData.length) { alert('No hay datos cargados. Por favor carga un archivo CSV primero.'); return; }

      showLoadingIndicator('Generando Excel profesional...');
      try {
        const wb = XLSX.utils.book_new();

        const headers = Object.keys(rawData[0] || {});
        schema = inferSchema(headers, rawData);
        const colEstado = headers.includes('Estado Final Incidente') ? 'Estado Final Incidente' : schema?.roles?.estado;
        const totals = getOpenClosedReturnedEmptyTotals(rawData, colEstado);

        /* ============ HOJA 1: PORTADA Y RESUMEN ============ */
        const coverData = buildExcelCoverSheet(totals);
        const wsCover = XLSX.utils.aoa_to_sheet(coverData);
        wsCover['!cols'] = [{ wch: 35 }, { wch: 20 }, { wch: 40 }];
        wsCover['!merges'] = [
          { s: { r: 0, c: 0 }, e: { r: 0, c: 2 } },
          { s: { r: 1, c: 0 }, e: { r: 1, c: 2 } },
          { s: { r: 4, c: 0 }, e: { r: 4, c: 2 } }
        ];
        XLSX.utils.book_append_sheet(wb, wsCover, 'üìä Resumen Ejecutivo');

        /* ============ HOJA 2: DATOS COMPLETOS ============ */
        const wsData = XLSX.utils.json_to_sheet(rawData);
        const colsKeys = Object.keys(rawData[0] || {});
        wsData['!cols'] = colsKeys.map(k => ({ wch: Math.min(35, Math.max(12, k.length + 4)) }));
        wsData['!freeze'] = { xSplit: 0, ySplit: 1, activePane: 'bottomLeft' };
        colsKeys.forEach((key, idx) => {
          const cellRef = XLSX.utils.encode_cell({ r: 0, c: idx });
          if (!wsData[cellRef]) return;
          wsData[cellRef].s = {
            fill: { fgColor: { rgb: "4361EE" } },
            font: { bold: true, color: { rgb: "FFFFFF" }, sz: 12 },
            alignment: { horizontal: "center", vertical: "center" }
          };
        });
        XLSX.utils.book_append_sheet(wb, wsData, 'üìã Datos Completos');

        /* ============ HOJA 3..10 ============ */
        const wsEstado = buildStateAnalysisSheet(colEstado, totals);
        XLSX.utils.book_append_sheet(wb, wsEstado, 'üîÑ An√°lisis Estado');

        const wsResp = buildResponsibleAnalysisSheet(colEstado);
        XLSX.utils.book_append_sheet(wb, wsResp, 'üë• Por Responsable');

        const wsServ = buildServiceAnalysisSheet();
        XLSX.utils.book_append_sheet(wb, wsServ, 'üõ†Ô∏è Por Servicio');

        const wsTime = buildTimeAnalysisSheet(colEstado);
        XLSX.utils.book_append_sheet(wb, wsTime, '‚è±Ô∏è Tiempo');

        const wsProv = buildProviderAnalysisSheet(colEstado);
        XLSX.utils.book_append_sheet(wb, wsProv, 'üè¢ Proveedores');

        const wsCat = buildCategoryAnalysisSheet(colEstado);
        XLSX.utils.book_append_sheet(wb, wsCat, 'üìë Categor√≠as');

        const wsInsights = buildInsightsSheet();
        XLSX.utils.book_append_sheet(wb, wsInsights, 'üí° Hallazgos');

        const wsDashboard = buildMetricsDashboardSheet(totals);
        XLSX.utils.book_append_sheet(wb, wsDashboard, 'üìà Dashboard KPIs');

        const fileName = `Dashboard_Completo_${new Date().toISOString().slice(0, 10)}.xlsx`;
        XLSX.writeFile(wb, fileName);

        hideLoadingIndicator();
        showSuccessNotification('Excel generado exitosamente con 10 hojas de an√°lisis');
      } catch (err) {
        console.error('Error generando Excel:', err);
        hideLoadingIndicator();
        showErrorNotification('Error al generar Excel: ' + err.message);
      }
    }

    /* ============ BUILDERS HOJAS EXCEL ============ */
    function buildExcelCoverSheet(totals) {
      const fecha = new Date().toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const tasaResolucion = ((totals.cerrados / totals.total) * 100).toFixed(1);
      return [
        ['DASHBOARD EJECUTIVO - BACKLOG INCIDENTES TI'],
        ['Banco Uni√≥n S.A - Gesti√≥n de Incidentes Nivel 2'],
        [''],
        ['Fecha de Generaci√≥n:', fecha],
        ['Archivo Fuente:', cleanText(window.__lastCsvName || 'Datos cargados')],
        ['Total de Registros:', totals.total],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√âTRICAS PRINCIPALES', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√©trica', 'Valor', 'Interpretaci√≥n'],
        ['Total de Incidentes', totals.total, totals.total > 0 ? '‚úì Carga activa' : '‚ö† Sin carga'],
        ['Incidentes Abiertos', totals.abiertos, totals.abiertos > totals.cerrados ? '‚ö† Requiere atenci√≥n urgente' : '‚úì Bajo control'],
        ['Incidentes Cerrados', totals.cerrados, totals.cerrados >= totals.abiertos ? '‚úì Buena resoluci√≥n' : '‚ö† Mejorar cierre'],
        ['Tasa de Resoluci√≥n', `${tasaResolucion}%`, Number(tasaResolucion) >= 70 ? '‚úì Excelente' : Number(tasaResolucion) >= 50 ? '‚ö† Aceptable' : '‚ùå Cr√≠tico'],
        ['Casos Devueltos', totals.devuelto, totals.devuelto > 10 ? '‚ö† Revisar proceso' : totals.devuelto > 0 ? '‚ö† Monitorear' : '‚úì OK'],
        ['Registros Vac√≠os', totals.vacios, totals.vacios > 0 ? '‚ö† Validar calidad de datos' : '‚úì Datos completos'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['INDICADORES DE SALUD DEL BACKLOG', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Indicador', 'Estado', 'Observaci√≥n'],
        ['Ratio Abiertos/Cerrados', totals.abiertos <= totals.cerrados ? '‚úì SALUDABLE' : '‚ö† CR√çTICO',
          `${(totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2)} - ${totals.abiertos <= totals.cerrados ? 'Mantener ritmo' : 'Aumentar cierre'}`],
        ['Calidad de Datos', totals.vacios === 0 ? '‚úì EXCELENTE' : totals.vacios < 5 ? '‚ö† BUENO' : '‚ùå DEFICIENTE',
          `${totals.vacios} registros vac√≠os de ${totals.total}`],
        ['Devoluciones', totals.devuelto < 5 ? '‚úì BAJO' : totals.devuelto < 20 ? '‚ö† MEDIO' : '‚ùå ALTO',
          `${((totals.devuelto / totals.total) * 100).toFixed(1)}% del total`],
        [''],
        [''],
        ['‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'],
        ['Elaborado por:', 'John Jairo Vargas Gonz√°lez', ''],
        ['Cargo:', 'Ingeniero de Soluciones TI', ''],
        ['Contacto:', 'john.vargas@bancounion.com', ''],
        ['‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ']
      ];
    }

    function buildStateAnalysisSheet(colEstado, totals) {
      const stateData = [
        ['AN√ÅLISIS DETALLADO POR ESTADO'],
        [''],
        ['Estado', 'Cantidad', '% del Total', 'Interpretaci√≥n', 'Acci√≥n Recomendada'],
        ['Abiertos', totals.abiertos, `${((totals.abiertos / totals.total) * 100).toFixed(2)}%`,
          totals.abiertos > totals.cerrados ? 'Backlog creciente' : 'Bajo control',
          totals.abiertos > totals.cerrados ? 'Priorizar cierre inmediato' : 'Mantener seguimiento'],
        ['Cerrados', totals.cerrados, `${((totals.cerrados / totals.total) * 100).toFixed(2)}%`, 'Incidentes resueltos', 'Analizar tiempos de resoluci√≥n'],
        ['Devueltos', totals.devuelto, `${((totals.devuelto / totals.total) * 100).toFixed(2)}%`,
          totals.devuelto > 10 ? 'Alto nivel de devoluciones' : 'Normal',
          totals.devuelto > 10 ? 'Revisar causas ra√≠z' : 'Monitoreo regular'],
        ['Vac√≠os', totals.vacios, `${((totals.vacios / totals.total) * 100).toFixed(2)}%`, 'Registros sin estado',
          totals.vacios > 0 ? 'Validar y corregir datos' : 'N/A'],
        ['TOTAL', totals.total, '100%', '', ''],
        [''],
        ['TENDENCIAS Y OBSERVACIONES'],
        [''],
        ['Ratio Abiertos/Cerrados:', (totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2)],
        ['Eficiencia de Cierre:', `${((totals.cerrados / totals.total) * 100).toFixed(1)}%`],
        ['Casos Problem√°ticos (Devueltos + Vac√≠os):', totals.devuelto + totals.vacios],
        [''],
        ['ALERTAS AUTOM√ÅTICAS'],
        [''],
        totals.abiertos > totals.cerrados ? ['‚ö† ALERTA: Backlog en crecimiento - Abiertos superan cerrados'] : ['‚úì Estado normal - Ritmo de cierre adecuado'],
        totals.devuelto > 15 ? ['‚ö† ALERTA: Alto nivel de devoluciones - Revisar proceso'] : ['‚úì Devoluciones dentro de par√°metros normales'],
        totals.vacios > 10 ? ['‚ö† ALERTA: Calidad de datos comprometida'] : ['‚úì Calidad de datos aceptable']
      ];
      const ws = XLSX.utils.aoa_to_sheet(stateData);
      ws['!cols'] = [{ wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 30 }, { wch: 35 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 4 } },
        { s: { r: 9, c: 0 }, e: { r: 9, c: 4 } },
        { s: { r: 14, c: 0 }, e: { r: 14, c: 4 } }
      ];
      return ws;
    }

    function buildResponsibleAnalysisSheet(colEstado) {
      const headers = Object.keys(rawData[0] || {});
      const colResp = headers.includes('Ingeniero Asignado') ? 'Ingeniero Asignado' : schema?.roles?.responsable;
      if (!colResp || !colEstado) return XLSX.utils.aoa_to_sheet([['No hay datos de responsables disponibles']]);

      const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
      const data = [['AN√ÅLISIS POR RESPONSABLE - TOP 20'], [''], ['Responsable', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'Eficiencia', 'Estado', 'Acci√≥n']];

      rowsResp.slice(0, 20).forEach(r => {
        const total = r.abiertos + r.cerrados;
        const eficiencia = ((r.cerrados / total) * 100).toFixed(1);
        const estado = Number(eficiencia) >= 70 ? '‚úì Bueno' : Number(eficiencia) >= 50 ? '‚ö† Regular' : '‚ùå Cr√≠tico';
        const accion = Number(eficiencia) < 50 ? 'Requiere soporte urgente' : Number(eficiencia) < 70 ? 'Monitorear de cerca' : 'Mantener ritmo';
        data.push([cleanText(r.label), r.abiertos, `${((r.abiertos / total) * 100).toFixed(1)}%`, r.cerrados, `${((r.cerrados / total) * 100).toFixed(1)}%`, total, `${eficiencia}%`, estado, accion]);
      });

      const totalAbiertos = rowsResp.reduce((sum, r) => sum + r.abiertos, 0);
      const totalCerrados = rowsResp.reduce((sum, r) => sum + r.cerrados, 0);
      const totalGeneral = totalAbiertos + totalCerrados;

      data.push(['']);
      data.push(['TOTALES', totalAbiertos, '', totalCerrados, '', totalGeneral, '', '', '']);
      data.push(['']);
      data.push(['ESTAD√çSTICAS']);
      data.push(['Responsables analizados:', rowsResp.length]);
      data.push(['Promedio casos por responsable:', Math.round(totalGeneral / rowsResp.length)]);
      data.push(['Responsable con m√°s abiertos:', rowsResp[0]?.label || 'N/A', rowsResp[0]?.abiertos || 0]);
      data.push(['Responsable con m√°s cerrados:',
        rowsResp.slice().sort((a, b) => b.cerrados - a.cerrados)[0]?.label || 'N/A',
        rowsResp.slice().sort((a, b) => b.cerrados - a.cerrados)[0]?.cerrados || 0
      ]);

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 30 }];
      ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 8 } }];
      return ws;
    }

    function buildServiceAnalysisSheet() {
      const colServ = schema?.roles?.servicio;
      if (!colServ) return XLSX.utils.aoa_to_sheet([['No hay datos de servicios disponibles']]);

      const counts = countBy(rawData, colServ);
      const total = counts.reduce((sum, c) => sum + c.value, 0);
      const data = [['AN√ÅLISIS POR SERVICIO / TIPIFICACI√ìN'], [''], ['Servicio', 'Cantidad', '% del Total', 'Impacto', 'Prioridad']];

      counts.forEach((s) => {
        const porcentaje = (s.value / total) * 100;
        const impacto = porcentaje > 20 ? 'ALTO' : porcentaje > 10 ? 'MEDIO' : 'BAJO';
        const prioridad = porcentaje > 20 ? 'P1 - Cr√≠tico' : porcentaje > 10 ? 'P2 - Alto' : porcentaje > 5 ? 'P3 - Medio' : 'P4 - Bajo';
        data.push([cleanText(s.label), Math.round(s.value), `${porcentaje.toFixed(2)}%`, impacto, prioridad]);
      });

      data.push(['']);
      data.push(['TOTAL', total, '100%', '', '']);
      data.push(['']);
      data.push(['CONCENTRACI√ìN DE CASOS']);
      data.push(['Top 5 servicios representan:', `${(((counts.slice(0, 5).reduce((sum, s) => sum + s.value, 0)) / total) * 100).toFixed(1)}%`]);
      data.push(['Top 10 servicios representan:', `${(((counts.slice(0, 10).reduce((sum, s) => sum + s.value, 0)) / total) * 100).toFixed(1)}%`]);
      data.push(['']);
      data.push(['RECOMENDACIONES']);
      counts.slice(0, 3).forEach((s, idx) => {
        data.push([`${idx + 1}. ${cleanText(s.label)}`, `Focalizar recursos - ${Math.round((s.value / total) * 100)}% del volumen`]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 50 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 20 }];
      ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 4 } }];
      return ws;
    }

    function buildTimeAnalysisSheet(colEstado) {
      const colTiempo = schema?.roles?.tiempo;
      if (!colTiempo) return XLSX.utils.aoa_to_sheet([['No hay datos de tiempo disponibles']]);

      const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
      if (!tiempos.length) return XLSX.utils.aoa_to_sheet([['No hay datos v√°lidos de tiempo']]);

      const promedio = average(tiempos);
      const max = Math.max(...tiempos);
      const min = Math.min(...tiempos);
      const mediana = tiempos.sort((a, b) => a - b)[Math.floor(tiempos.length / 2)];

      const rangos = [
        { label: '0-7 d√≠as', min: 0, max: 7, count: 0 },
        { label: '8-15 d√≠as', min: 8, max: 15, count: 0 },
        { label: '16-30 d√≠as', min: 16, max: 30, count: 0 },
        { label: '31-60 d√≠as', min: 31, max: 60, count: 0 },
        { label: '61-90 d√≠as', min: 61, max: 90, count: 0 },
        { label: 'M√°s de 90 d√≠as', min: 91, max: Infinity, count: 0 }
      ];
      tiempos.forEach(t => { const r = rangos.find(rg => t >= rg.min && t <= rg.max); if (r) r.count++; });

      const data = [
        ['AN√ÅLISIS DE TIEMPO Y RENDIMIENTO'],
        [''],
        ['ESTAD√çSTICAS GENERALES'],
        ['M√©trica', 'Valor (d√≠as)', 'Interpretaci√≥n'],
        ['Tiempo Promedio', Math.round(promedio), promedio > 30 ? '‚ö† Ciclo lento' : '‚úì Aceptable'],
        ['Tiempo M√°ximo', Math.round(max), max > 90 ? '‚ùå Caso cr√≠tico' : max > 60 ? '‚ö† Alto' : '‚úì Normal'],
        ['Tiempo M√≠nimo', Math.round(min), min < 1 ? '‚ö† Revisar' : '‚úì R√°pido'],
        ['Mediana', Math.round(mediana), ''],
        ['Casos Analizados', tiempos.length, ''],
        [''],
        ['DISTRIBUCI√ìN POR RANGOS DE TIEMPO'],
        ['Rango', 'Cantidad', '% del Total', 'Estado'],
        ...rangos.map(r => [r.label, r.count, `${((r.count / tiempos.length) * 100).toFixed(1)}%`,
        r.label.includes('M√°s de 90') && r.count > 0 ? '‚ùå Cr√≠tico' :
          r.label.includes('61-90') && r.count > tiempos.length * 0.2 ? '‚ö† Alto' : '‚úì']),
        ['TOTAL', tiempos.length, '100%', ''],
        [''],
        ['AN√ÅLISIS DE ALERTAS'],
        [''],
        promedio > 30 ? ['‚ö† Tiempo promedio superior a 30 d√≠as - Revisar procesos'] : ['‚úì Tiempo promedio dentro de par√°metros'],
        rangos[5].count > 0 ? [`‚ö† ${rangos[5].count} casos con m√°s de 90 d√≠as - Atenci√≥n urgente`] : ['‚úì No hay casos cr√≠ticos por tiempo'],
        max > 180 ? [`‚ùå Caso m√°s antiguo: ${Math.round(max)} d√≠as - Escalamiento necesario`] : ['‚úì Casos antiguos bajo control']
      ];
      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 25 }, { wch: 18 }, { wch: 18 }, { wch: 35 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 3 } },
        { s: { r: 2, c: 0 }, e: { r: 2, c: 3 } },
        { s: { r: 10, c: 0 }, e: { r: 10, c: 3 } },
        { s: { r: 15, c: 0 }, e: { r: 15, c: 3 } }
      ];
      return ws;
    }

    function buildProviderAnalysisSheet(colEstado) {
      const headers = Object.keys(rawData[0] || {});
      const colProv = headers.includes('Proveedor a escalar') ? 'Proveedor a escalar' : schema?.roles?.proveedor;
      if (!colProv || !colEstado) return XLSX.utils.aoa_to_sheet([['No hay datos de proveedores disponibles']]);

      const rowsProv = getOpenClosedByProvider(rawData, colProv, colEstado);
      const data = [['AN√ÅLISIS POR PROVEEDOR'], [''], ['Proveedor', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'SLA Cumpl.', 'Criticidad']];

      rowsProv.forEach(p => {
        const total = p.abiertos + p.cerrados;
        const sla = ((p.cerrados / total) * 100).toFixed(1);
        const criticidad = Number(sla) < 50 ? '‚ùå Cr√≠tico' : Number(sla) < 70 ? '‚ö† Medio' : '‚úì Bueno';
        data.push([cleanText(p.label), p.abiertos, `${((p.abiertos / total) * 100).toFixed(1)}%`, p.cerrados, `${((p.cerrados / total) * 100).toFixed(1)}%`, total, `${sla}%`, criticidad]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 18 }];
      return ws;
    }

    function buildCategoryAnalysisSheet(colEstado) {
      const headers = Object.keys(rawData[0] || {});
      const colCat = headers.includes('Categor√≠a') ? 'Categor√≠a' : headers.find(h => /categor[i√≠]a/i.test(h));
      if (!colCat || !colEstado) return XLSX.utils.aoa_to_sheet([['No hay datos de categor√≠as disponibles']]);

      const rowsCat = getOpenClosedByCategory(rawData, colCat, colEstado);
      const data = [['AN√ÅLISIS POR CATEGOR√çA'], [''], ['Categor√≠a', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'Ratio A/C']];

      rowsCat.forEach(c => {
        const ratio = c.cerrados > 0 ? (c.abiertos / c.cerrados).toFixed(2) : 'N/A';
        data.push([cleanText(c.label), c.abiertos, `${((c.abiertos / c.total) * 100).toFixed(1)}%`, c.cerrados, `${((c.cerrados / c.total) * 100).toFixed(1)}%`, c.total, ratio]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 40 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }];
      return ws;
    }

    function buildInsightsSheet() {
      const narrative = buildExecutiveNarrative(rawData, schema);
      const data = [
        ['HALLAZGOS Y RECOMENDACIONES ESTRAT√âGICAS'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['RESUMEN EJECUTIVO'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ...narrative.resumen.map(line => [cleanText(line)]),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['‚ö† RIESGOS IDENTIFICADOS'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ...narrative.riesgos.map(line => ['‚Ä¢ ' + cleanText(line)]),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['‚úì ACCIONES RECOMENDADAS (PR√ìXIMOS 30 D√çAS)'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ...narrative.acciones.map(line => ['‚Ä¢ ' + cleanText(line)]),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['TOP 5 RESPONSABLES CON M√ÅS CASOS ABIERTOS'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Responsable', 'Abiertos', 'Cerrados', 'Total'],
        ...narrative.topRespAbiertos.map(r => [cleanText(r.label), r.abiertos, r.cerrados, r.total]),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['TOP 5 PROVEEDORES CR√çTICOS'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Proveedor', 'Abiertos', 'Cerrados', 'Total'],
        ...narrative.topProvAbiertos.map(r => [cleanText(r.label), r.abiertos, r.cerrados, r.total]),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['TOP 5 SERVICIOS POR VOLUMEN'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Servicio', 'Casos', '% del Total'],
        ...(() => {
          const totalTop = narrative.topServicios.reduce((sum, srv) => sum + srv.value, 0);
          return narrative.topServicios.map(s => [cleanText(s.label), Math.round(s.value), `${(((s.value) / totalTop) * 100).toFixed(1)}%`]);
        })()
      ];
      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 80 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
      ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 3 } }];
      return ws;
    }

    function buildMetricsDashboardSheet(totals) {
      const colTiempo = schema?.roles?.tiempo;
      let promedioTiempo = 0;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        if (tiempos.length) promedioTiempo = average(tiempos);
      }

      const tasaResolucion = ((totals.cerrados / totals.total) * 100).toFixed(1);
      const ratio = (totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2);

      const data = [
        ['üìà DASHBOARD DE INDICADORES CLAVE (KPIs)'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['KPI PRINCIPAL', 'VALOR ACTUAL', 'META', 'CUMPLIMIENTO', 'TENDENCIA'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Total Incidentes', totals.total, 'N/A', '‚Äî', totals.total > 500 ? 'üìà Alto volumen' : 'üìä Normal'],
        ['Tasa de Resoluci√≥n', `${tasaResolucion}%`, '‚â• 70%', Number(tasaResolucion) >= 70 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', Number(tasaResolucion) >= 70 ? 'üìà Excelente' : 'üìâ Mejorar'],
        ['Tiempo Promedio Resoluci√≥n', `${Math.round(promedioTiempo)} d√≠as`, '‚â§ 30 d√≠as', promedioTiempo <= 30 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', promedioTiempo <= 30 ? '‚úì Dentro de SLA' : '‚ö† Fuera de SLA'],
        ['Ratio Abiertos/Cerrados', ratio, '‚â§ 1.0', Number(ratio) <= 1.0 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', Number(ratio) <= 1.0 ? 'üìà Saludable' : 'üìâ Cr√≠tico'],
        ['Backlog Actual (Abiertos)', totals.abiertos, `‚â§ ${Math.round(totals.total * 0.3)}`, totals.abiertos <= totals.total * 0.3 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', totals.abiertos <= totals.cerrados ? 'üìâ Decreciendo' : 'üìà Creciendo'],
        ['Calidad de Datos', `${totals.total - totals.vacios} registros`, '100%', totals.vacios === 0 ? '‚úÖ CUMPLE' : '‚ö† REVISAR', totals.vacios === 0 ? '‚úì Excelente' : '‚ö† Validar'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['SEM√ÅFORO DE SALUD DEL BACKLOG'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        [''],
        ['Indicador', 'Estado Visual', 'Descripci√≥n'],
        ...calcularSemaforo(totals, tasaResolucion, promedioTiempo, ratio),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['SCORE GENERAL DEL BACKLOG'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        [''],
        ...calcularScore(totals, tasaResolucion, promedioTiempo, ratio)
      ];

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 20 }, { wch: 15 }, { wch: 18 }, { wch: 25 }];
      ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 4 } }];
      return ws;
    }

    function calcularSemaforo(totals, tasaResolucion, promedioTiempo, ratio) {
      const items = [];
      // Tasa de resoluci√≥n
      if (Number(tasaResolucion) >= 70) items.push(['Tasa de Resoluci√≥n', 'üü¢ VERDE', `Excelente: ${tasaResolucion}%`]);
      else if (Number(tasaResolucion) >= 50) items.push(['Tasa de Resoluci√≥n', 'üü° AMARILLO', `Regular: ${tasaResolucion}%`]);
      else items.push(['Tasa de Resoluci√≥n', 'üî¥ ROJO', `Cr√≠tico: ${tasaResolucion}%`]);

      // Tiempo promedio
      if (promedioTiempo <= 30) items.push(['Tiempo Promedio', 'üü¢ VERDE', `√ìptimo: ${Math.round(promedioTiempo)} d√≠as`]);
      else if (promedioTiempo <= 60) items.push(['Tiempo Promedio', 'üü° AMARILLO', `Aceptable: ${Math.round(promedioTiempo)} d√≠as`]);
      else items.push(['Tiempo Promedio', 'üî¥ ROJO', `Cr√≠tico: ${Math.round(promedioTiempo)} d√≠as`]);

      // Ratio
      if (Number(ratio) <= 1.0) items.push(['Ratio A/C', 'üü¢ VERDE', `Saludable: ${ratio}`]);
      else if (Number(ratio) <= 1.5) items.push(['Ratio A/C', 'üü° AMARILLO', `Atenci√≥n: ${ratio}`]);
      else items.push(['Ratio A/C', 'üî¥ ROJO', `Cr√≠tico: ${ratio}`]);

      // Calidad de datos
      if (totals.vacios === 0) items.push(['Calidad de Datos', 'üü¢ VERDE', '100% completo']);
      else if (totals.vacios <= 10) items.push(['Calidad de Datos', 'üü° AMARILLO', `${totals.vacios} registros vac√≠os`]);
      else items.push(['Calidad de Datos', 'üî¥ ROJO', `${totals.vacios} registros vac√≠os`]);

      return items;
    }

    function calcularScore(totals, tasaResolucion, promedioTiempo, ratio) {
      let score = 0; const maxScore = 100;
      if (Number(tasaResolucion) >= 70) score += 30; else if (Number(tasaResolucion) >= 50) score += 20; else score += 10;
      if (promedioTiempo <= 30) score += 25; else if (promedioTiempo <= 60) score += 15; else score += 5;
      if (Number(ratio) <= 1.0) score += 25; else if (Number(ratio) <= 1.5) score += 15; else score += 5;
      if (totals.vacios === 0) score += 20; else if (totals.vacios <= 10) score += 10;

      const porcentaje = ((score / maxScore) * 100).toFixed(1);
      let clasificacion = '', recomendacion = '';
      if (score >= 80) { clasificacion = 'üèÜ EXCELENTE'; recomendacion = 'Backlog en estado √≥ptimo. Mantener pr√°cticas actuales.'; }
      else if (score >= 60) { clasificacion = '‚úÖ BUENO'; recomendacion = 'Backlog controlado. Monitorear √°reas de mejora.'; }
      else if (score >= 40) { clasificacion = '‚ö†Ô∏è REGULAR'; recomendacion = 'Requiere atenci√≥n. Implementar plan de acci√≥n.'; }
      else { clasificacion = '‚ùå CR√çTICO'; recomendacion = 'Situaci√≥n cr√≠tica. Intervenci√≥n urgente necesaria.'; }

      return [
        ['Score Total:', `${score} / ${maxScore}`, '', `${porcentaje}%`, ''],
        ['Clasificaci√≥n:', clasificacion, '', '', ''],
        ['Recomendaci√≥n:', recomendacion, '', '', ''],
        [''],
        ['Desglose de Puntuaci√≥n:'],
        ['‚Ä¢ Tasa de Resoluci√≥n', '', '30 puntos m√°x.', '', ''],
        ['‚Ä¢ Tiempo Promedio', '', '25 puntos m√°x.', '', ''],
        ['‚Ä¢ Ratio Abiertos/Cerrados', '', '25 puntos m√°x.', '', ''],
        ['‚Ä¢ Calidad de Datos', '', '20 puntos m√°x.', '', '']
      ];
    }

    /* ============ UI: INDICADORES Y NOTIFICACIONES ============ */
    function showLoadingIndicator(message) {
      let overlay = document.getElementById('loadingOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'loadingOverlay';
        overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(11, 18, 32, 0.95); display: flex; align-items: center; justify-content: center;
      z-index: 9999; backdrop-filter: blur(8px);
    `;
        overlay.innerHTML = `
      <div style="text-align: center; color: white;">
        <div style="
          width: 60px; height: 60px; border: 4px solid rgba(76, 201, 240, 0.2);
          border-top-color: #4cc9f0; border-radius: 50%; margin: 0 auto 20px; animation: spin 1s linear infinite;">
        </div>
        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Generando reporte...</div>
        <div id="loadingMessage" style="font-size: 14px; color: #9ca3af;">Por favor espere</div>
      </div>
    `;
        const style = document.createElement('style');
        style.textContent = `@keyframes spin { to { transform: rotate(360deg); } }`;
        document.head.appendChild(style);
        document.body.appendChild(overlay);
      }
      const msgElement = document.getElementById('loadingMessage');
      if (msgElement) msgElement.textContent = message;
      overlay.style.display = 'flex';
    }

    function hideLoadingIndicator() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) overlay.style.display = 'none';
    }

    function showSuccessNotification(message) { showNotification(message, 'success'); }
    function showErrorNotification(message) { showNotification(message, 'error'); }

    function showNotification(message, type) {
      const notification = document.createElement('div');
      notification.style.cssText = `
    position: fixed; top: 80px; right: 20px; background: ${type === 'success' ? '#2a9d8f' : '#e76f51'};
    color: white; padding: 16px 24px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000; font-weight: 600; font-size: 14px; display: flex; align-items: center; gap: 12px; min-width: 300px;
    animation: slideIn 0.3s ease-out;
  `;
      const icon = type === 'success' ? '‚úì' : '‚úï';
      notification.innerHTML = `<span style="font-size: 20px;">${icon}</span> <span>${message}</span>`;
      const style = document.createElement('style');
      style.textContent = `
    @keyframes slideIn {
      from { transform: translateX(400px); opacity: 0; }
      to   { transform: translateX(0); opacity: 1; }
    }
  `;
      document.head.appendChild(style);
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    /* ============ OVERRIDE DE EXPORTS ORIGINALES ============ */
    /* Para asegurar que los botones existentes llamen las versiones modernas: */
    function generatePDFReport() { return generateModernPDFReport(); }
    function generateExcelReport() { return generateModernExcelReport(); }

    /* Adem√°s, exponemos en window por compatibilidad con cualquier c√≥digo externo: */
    window.generatePDFReport = generateModernPDFReport;
    window.generateExcelReport = generateModernExcelReport;
    function buildSummarySheet(totals, tasaResolucion, fecha) {
      return [
        ['REPORTE DE AN√ÅLISIS DE BACKLOG DE INCIDENTES'],
        [''],
        ['Fecha de Generaci√≥n:', fecha],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['RESUMEN DEL REPORTE', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Par√°metro', 'Valor'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Total de Incidentes', totals.total],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['INDICADORES CLAVE DE DESEMPE√ëO (KPIs)', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Indicador', 'Valor', 'Interpretaci√≥n'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Incidentes Abiertos', totals.abiertos, totals.abiertos > totals.cerrados ? '‚ö† Atenci√≥n requerida' : '‚úì Bajo control'],
        ['Incidentes Cerrados', totals.cerrados, totals.cerrados >= totals.abiertos ? '‚úì Buen ritmo' : '‚ö† Mejorar cierre'],
        ['Tasa de Resoluci√≥n', `${tasaResolucion}%`, Number(tasaResolucion) >= 70 ? '‚úì Cumple objetivo' : '‚ùå Por debajo del objetivo'],
        ['Incidentes Devueltos', totals.devuelto, totals.devuelto < 5 ? '‚úì Nivel bajo' : totals.devuelto < 20 ? '‚ö† Nivel medio' : '‚ùå Nivel alto'],
        ['Registros Vac√≠os', totals.vacios, totals.vacios === 0 ? '‚úì Excelente' : totals.vacios < 5 ? '‚ö† Bueno' : '‚ùå Deficiente'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['AN√ÅLISIS R√ÅPIDO Y RECOMENDACIONES', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√©trica', 'Valor', 'Recomendaci√≥n'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Ratio Abiertos/Cerrados', (A / C), (totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2),
          (totals.abiertos > totals.cerrados) ? 'Priorizar cierre de casos abiertos' : 'Mantener ritmo de cierre'],
        ['Tiempo Promedio de Resoluci√≥n', schema?.roles?.tiempo ? `${Math.round(average(rawData.map(r => parseNumber(r[schema.roles.tiempo])).filter(n => !isNaN(n))))} d√≠as` : 'N/A',
          schema?.roles?.tiempo ? (average(rawData.map(r => parseNumber(r[schema.roles.tiempo])).filter(n => !isNaN(n))) > 30 ? 'Revisar procesos para mejorar tiempos' : 'Continuar con buenas pr√°cticas') : 'N/A'],
        ['Calidad de Datos', totals.total - totals.vacios,
          totals.vacios === 0 ? 'Mantener calidad de datos' : 'Validar y corregir registros incompletos'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['NOTAS ADICIONALES', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['‚Ä¢ Este reporte proporciona una visi√≥n general del estado actual del backlog de incidentes.'],
        ['‚Ä¢ Se recomienda revisar los an√°lisis detallados en las hojas siguientes para acciones espec√≠ficas.'],
        ['‚Ä¢ Mantener un monitoreo constante de los KPIs para asegurar la salud del backlog.']
      ];
    }

    function buildStateAnalysisSheet(totals) {
      const stateData = [
        ['AN√ÅLISIS POR ESTADO DE INCIDENTES'],
        [''],
        ['Estado', 'Cantidad', '% del Total', 'Descripci√≥n', 'Recomendaci√≥n'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Abiertos', totals.abiertos, `${((totals.abiertos / totals.total) * 100).toFixed(2)}%`, 'Incidentes pendientes',
          totals.abiertos > totals.cerrados ? 'Priorizar cierre' : 'Ritmo adecuado'],
        ['Cerrados', totals.cerrados, `${((totals.cerrados / totals.total) * 100).toFixed(2)}%`, 'Incidentes resueltos',
          totals.cerrados >= totals.abiertos ? 'Mantener ritmo' : 'Mejorar cierre'],
        ['Devueltos', totals.devuelto, `${((totals.devuelto / totals.total) * 100).toFixed(2)}%`, 'Incidentes rechazados',
          totals.devuelto > 15 ? 'Revisar calidad' : 'Nivel aceptable'],
        ['Vac√≠os', totals.vacios, `${((totals.vacios / totals.total) * 100).toFixed(2)}%`, 'Registros incompletos',
          totals.vacios > 10 ? 'Corregir datos' : 'Calidad aceptable'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['RESUMEN Y ALERTAS'],
        [''],
        ['RESUMEN GENERAL'],
        [''],
        ['Total Incidentes Analizados:', totals.total],
        ['Incidentes Abiertos:', totals.abiertos],
        ['Incidentes Cerrados:', totals.cerrados],
        ['Incidentes Devueltos:', totals.devuelto],
        ['Registros Vac√≠os:', totals.vacios],
        [''],
        ['INDICADORES CLAVE'],
        [''],
        ['Tasa de Resoluci√≥n:', `${((totals.cerrados / totals.total) * 100).toFixed(1)}%`],
        ['Ratio Abiertos/Cerrados:', (totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2)],
        [''],
        ['ALERTAS'],
        [''],
        totals.abiertos > totals.cerrados ? ['‚ö† Alto volumen de incidentes abiertos - Priorizar cierre'] : ['‚úì Volumen de abiertos bajo control'],
        totals.devuelto > 15 ? [`‚ö† Elevado n√∫mero de incidentes devueltos (${totals.devuelto}) - Revisar calidad`] : ['‚úì Nivel de devueltos aceptable'],
        totals.vacios > 10 ? [`‚ö† Muchos registros vac√≠os (${totals.vacios}) - Corregir datos`] : ['‚úì Calidad de datos adecuada']
      ];
      const ws = XLSX.utils.aoa_to_sheet(stateData);
      ws['!cols'] = [{ wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 40 }, { wch: 40 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 4 } },
        { s: { r: 2, c: 0 }, e: { r: 2, c: 4 } },
        { s: { r: 12, c: 0 }, e: { r: 12, c: 4 } }
      ];
      return ws;
    }

    function buildResponsibleAnalysisSheet(colEstado) {
      const colResp = schema?.roles?.responsable;
      if (!colResp || !colEstado) return XLSX.utils.aoa_to_sheet([['No hay datos de responsables disponibles']]);

      const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
      const data = [['AN√ÅLISIS POR RESPONSABLE'], [''], ['Responsable', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'Eficiencia', 'Estado', 'Acci√≥n Recomendada']];

      rowsResp.forEach(r => {
        const total = r.abiertos + r.cerrados;
        const eficiencia = ((r.cerrados / total) * 100).toFixed(1);
        const estado = Number(eficiencia) < 50 ? '‚ùå Cr√≠tico' : Number(eficiencia) < 70 ? '‚ö† Medio' : '‚úì Bueno';
        const accion = Number(eficiencia) < 70 ? 'Mejorar gesti√≥n' : 'Mantener desempe√±o';
        data.push([cleanText(r.label), r.abiertos, `${((r.abiertos / total) * 100).toFixed(1)}%`, r.cerrados, `${((r.cerrados / total) * 100).toFixed(1)}%`, total, `${eficiencia}%`, estado, accion]);
      });

      const totalAbiertos = rowsResp.reduce((sum, r) => sum + r.abiertos, 0);
      const totalCerrados = rowsResp.reduce((sum, r) => sum + r.cerrados, 0);
      const totalGeneral = totalAbiertos + totalCerrados;
      data.push(['']);
      data.push(['TOTAL', totalAbiertos, `${((totalAbiertos / totalGeneral) * 100).toFixed(1)}%`, totalCerrados, `${((totalCerrados / totalGeneral) * 100).toFixed(1)}%`, totalGeneral, '', '', '']);
      data.push(['']);
      data.push(['RESUMEN Y DESTACADOS']);
      data.push(['']);
      data.push(['Responsable con m√°s casos:', rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.label || 'N/A',
        (rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.abiertos + rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.cerrados) || 0]);
      data.push(['Responsable con mejor eficiencia:', rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0]?.label || 'N/A',
        `${rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0] ? ((rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados / (rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].abiertos + rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados)) * 100).toFixed(1) : '0'}%`]);
      data.push(['']);

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 25 }];
      return ws;
    }

    function buildServiceAnalysisSheet() {
      const colServicio = schema?.roles?.servicio;
      if (!colServicio) return XLSX.utils.aoa_to_sheet([['No hay datos de servicios disponibles']]);

      const serviceCounts = {};
      rawData.forEach(r => {
        const servicio = r[colServicio] ? String(r[colServicio]).trim() : 'Sin Servicio';
        serviceCounts[servicio] = (serviceCounts[servicio] || 0) + 1;
      });

      const counts = Object.entries(serviceCounts).map(([label, value]) => ({ label, value }));
      counts.sort((a, b) => b.value - a.value);
      const total = counts.reduce((sum, s) => sum + s.value, 0);

      const data = [['AN√ÅLISIS POR SERVICIO'], [''], ['Servicio', 'Recomendaci√≥n Estrat√©gica']];
      counts.forEach(s => {
        const porcentaje = (s.value / total) * 100;
        let recomendacion = '';
        if (porcentaje > 30) recomendacion = '‚ùå Alto volumen - Revisar recursos';
        else if (porcentaje > 15) recomendacion = '‚ö† Medio volumen - Monitorear desempe√±o';
        else recomendacion = '‚úì Bajo volumen - Mantener seguimiento';
        data.push([cleanText(s.label), recomendacion]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 50 }, { wch: 40 }];
      return ws;
    }

    function buildTimeAnalysisSheet(colTiempo) {
      if (!colTiempo) return XLSX.utils.aoa_to_sheet([['No hay datos de tiempo disponibles']]);

      const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
      if (tiempos.length === 0) return XLSX.utils.aoa_to_sheet([['No hay datos de tiempo disponibles']]);

      const promedio = average(tiempos);
      const max = Math.max(...tiempos);
      const min = Math.min(...tiempos);
      const mediana = median(tiempos);

      const rangos = [
        { label: '0-1 d√≠as', min: 0, max: 1, count: 0 },
        { label: '2-5 d√≠as', min: 2, max: 5, count: 0 },
        { label: '6-15 d√≠as', min: 6, max: 15, count: 0 },
        { label: '16-30 d√≠as', min: 16, max: 30, count: 0 },
        { label: '31-60 d√≠as', min: 31, max: 60, count: 0 },
        { label: '61-90 d√≠as', min: 61, max: 90, count: 0 },
        { label: 'M√°s de 90 d√≠as', min: 91, max: Infinity, count: 0 }
      ];

      tiempos.forEach(t => {
        for (const rango of rangos) {
          if (t >= rango.min && t <= rango.max) {
            rango.count += 1;
            break;
          }
        }
      });

      const data = [
        ['AN√ÅLISIS DE TIEMPOS DE RESOLUCI√ìN'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√âTRICAS PRINCIPALES'],
        [''],
        ['M√©trica', 'Valor'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Tiempo Promedio de Resoluci√≥n', `${Math.round(promedio)} d√≠as`],
        ['Tiempo M√°ximo de Resoluci√≥n', `${Math.round(max)} d√≠as`],
        ['Tiempo M√≠nimo de Resoluci√≥n', `${Math.round(min)} d√≠as`],
        ['Mediana de Tiempo de Resoluci√≥n', `${Math.round(mediana)} d√≠as`],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['DISTRIBUCI√ìN DE TIEMPOS'],
        [''],
        ['Rango de D√≠as', 'Cantidad de Casos', '% del Total', 'Nivel de Riesgo'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ...rangos.map(r => [r.label, r.count, `${((r.count / tiempos.length) * 100).toFixed(2)}%`,
        (r.count / tiempos.length) * 100 > 30 ? '‚ùå Alto' : (r.count / tiempos.length) * 100 > 15 ? '‚ö† Medio' : '‚úì Bajo'])
      ];

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 25 }, { wch: 20 }, { wch: 15 }, { wch: 20 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 3 } },
        { s: { r: 3, c: 0 }, e: { r: 3, c: 3 } },
        { s: { r: 12, c: 0 }, e: { r: 12, c: 3 } },
        { s: { r: 14, c: 0 }, e: { r: 14, c: 3 } },
      ];
      return ws;
    }

    function buildProviderAnalysisSheet(colEstado) {
      const headers = Object.keys(rawData[0] || {});
      const colProv = headers.includes('Proveedor') ? 'Proveedor' : headers.find(h => /proveedor/i.test(h));
      if (!colProv || !colEstado) return XLSX.utils.aoa_to_sheet([['No hay datos de proveedores disponibles']]);

      const rowsProv = getOpenClosedByProvider(rawData, colProv, colEstado);
      const data = [['AN√ÅLISIS POR PROVEEDOR'], [''], ['Proveedor', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'SLA Cumpl.', 'Criticidad']];

      rowsProv.forEach(p => {
        const total = p.abiertos + p.cerrados;
        const sla = ((p.cerrados / total) * 100).toFixed(1);
        const criticidad = Number(sla) < 50 ? '‚ùå Cr√≠tico' : Number(sla) < 70 ? '‚ö† Medio' : '‚úì Bueno';
        data.push([cleanText(p.label), p.abiertos, `${((p.abiertos / total) * 100).toFixed(1)}%`, p.cerrados, `${((p.cerrados / total) * 100).toFixed(1)}%`, total, `${sla}%`, criticidad]);
      });

      const totalAbiertos = rowsProv.reduce((sum, p) => sum + p.abiertos, 0);
      const totalCerrados = rowsProv.reduce((sum, p) => sum + p.cerrados, 0);
      const totalGeneral = totalAbiertos + totalCerrados;
      data.push(['']);
      data.push(['TOTAL', totalAbiertos, `${((totalAbiertos / totalGeneral) * 100).toFixed(1)}%`, totalCerrados, `${((totalCerrados / totalGeneral) * 100).toFixed(1)}%`, totalGeneral, '', '']);
      data.push(['']);
      data.push(['RESUMEN Y DESTACADOS']);
      data.push(['']);
      data.push(['Proveedor con m√°s casos:', rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.label || 'N/A',
        (rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.abiertos + rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.cerrados) || 0]);
      data.push(['Proveedor con mejor SLA:', rowsProv.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0]?.label || 'N/A',
        `${rowsProv.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0] ? ((rowsProv.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados / (rowsProv.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].abiertos + rowsProv.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados)) * 100).toFixed(1) : '0'}%`]);
      data.push(['']);

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 25 }];
      return ws;
    }

    function buildNarrativeSheet(narrative) {
      const data = [
        ['AN√ÅLISIS NARRATIVO DEL BACKLOG DE INCIDENTES'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['TOP 5 RESPONSABLES CON M√ÅS CASOS ABIERTOS'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        [''],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Nota: Este an√°lisis identifica a los responsables con mayor n√∫mero de incidentes abiertos, lo que puede indicar √°reas que requieren atenci√≥n prioritaria para mejorar la gesti√≥n y resoluci√≥n de casos.'],
        [''],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Responsables con M√°s Casos Abiertos'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Este apartado destaca a los responsables que tienen la mayor cantidad de incidentes abiertos en el backlog. Identificar a estos responsables es crucial para enfocar esfuerzos de mejora y optimizaci√≥n en la gesti√≥n de incidentes.'],
        [''],
        ['Responsable', 'Casos Abiertos', '% del Total Abiertos'],
        ...(() => {
          const totalAbiertos = narrative.topResponsables.reduce((sum, resp) => sum + resp.value, 0);
          return narrative.topResponsables.map(resp => [
            cleanText(resp.label),
            resp.value,
            `${((resp.value / totalAbiertos) * 100).toFixed(2)}%`
          ]);
        })(),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['INSIGHTS Y RECOMENDACIONES'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        [''],
        ...narrative.insights.map(insight => [`‚Ä¢ ${insight}`]),
        ['']
      ];

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 40 }, { wch: 20 }, { wch: 20 }];
      return ws;
    }

    function buildSummaryKpiSheet(totals) {
      let promedioTiempo = 0;
      const colTiempo = schema?.roles?.tiempo;
      if (colTiempo) {
        const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
        promedioTiempo = average(tiempos);
      }

      const tasaResolucion = ((totals.cerrados / totals.total) * 100).toFixed(1);
      const ratio = (totals.abiertos / Math.max(1, totals.cerrados)).toFixed(2);

      const data = [
        ['RESUMEN DE INDICADORES CLAVE DE DESEMPE√ëO (KPIs) DEL BACKLOG DE INCIDENTES'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['INDICADORES CLAVE DE DESEMPE√ëO (KPIs)'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Indicador', 'Valor Actual', 'Meta Objetivo', 'Cumplimiento', 'An√°lisis'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Tasa de Resoluci√≥n', `${tasaResolucion}%`, '‚â• 70%', Number(tasaResolucion) >= 70 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', Number(tasaResolucion) >= 70 ? '‚úì Buen ritmo' : '‚ö† Mejorar'],
        ['Tiempo Promedio de Resoluci√≥n', schema?.roles?.tiempo ? `${Math.round(promedioTiempo)} d√≠as` : 'N/A', '‚â§ 30 d√≠as', schema?.roles?.tiempo ? (promedioTiempo <= 30 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE') : 'N/A',
          schema?.roles?.tiempo ? (promedioTiempo <= 30 ? '‚úì √ìptimo' : promedioTiempo <= 60 ? '‚ö† Aceptable' : '‚ùå Cr√≠tico') : 'N/A'],
        ['Ratio Abiertos/Cerrados', ratio, '‚â§ 1.0', Number(ratio) <= 1.0 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE', Number(ratio) <= 1.0 ? '‚úì Saludable' : Number(ratio) <= 1.5 ? '‚ö† Atenci√≥n' : '‚ùå Cr√≠tico'],
        ['Calidad de Datos', `${totals.total - totals.vacios} registros completos`, '100% completo', totals.vacios === 0 ? '‚úÖ CUMPLE' : '‚ùå NO CUMPLE',
          totals.vacios === 0 ? '‚úì Excelente' : totals.vacios <= 10 ? '‚ö† Bueno' : '‚ùå Deficiente'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['SEMAFORO DE INDICADORES'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Indicador', 'Sem√°foro', 'Interpretaci√≥n'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ...calcularSemaforo(totals, tasaResolucion, promedioTiempo, ratio),
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['SCORE TOTAL Y RECOMENDACIONES'],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ...calcularScore(totals, tasaResolucion, promedioTiempo, ratio)
      ];

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 30 }, { wch: 15 }, { wch: 25 }, { wch: 15 }, { wch: 40 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 4 } },
        { s: { r: 3, c: 0 }, e: { r: 3, c: 4 } },
        { s: { r: 13, c: 0 }, e: { r: 13, c: 4 } },
        { s: { r: 17, c: 0 }, e: { r: 17, c: 4 } },
        { s: { r: 27, c: 0 }, e: { r: 27, c: 4 } }
      ];
      return ws;
    }

    function calcularSemaforo(totals, tasaResolucion, promedioTiempo, ratio) {
      const items = [];

      // Tasa de Resoluci√≥n
      if (Number(tasaResolucion) >= 70) items.push(['Tasa de Resoluci√≥n', 'üü¢ VERDE', `Cumple: ${tasaResolucion}%`]);
      else if (Number(tasaResolucion) >= 50) items.push(['Tasa de Resoluci√≥n', 'üü° AMARILLO', `Atenci√≥n: ${tasaResolucion}%`]);
      else items.push(['Tasa de Resoluci√≥n', 'üî¥ ROJO', `Cr√≠tico: ${tasaResolucion}%`]);

      // Tiempo Promedio
      if (promedioTiempo <= 30) items.push(['Tiempo Promedio de Resoluci√≥n', 'üü¢ VERDE', `√ìptimo: ${Math.round(promedioTiempo)} d√≠as`]);
      else if (promedioTiempo <= 60) items.push(['Tiempo Promedio de Resoluci√≥n', 'üü° AMARILLO', `Aceptable: ${Math.round(promedioTiempo)} d√≠as`]);
      else items.push(['Tiempo Promedio de Resoluci√≥n', 'üî¥ ROJO', `Cr√≠tico: ${Math.round(promedioTiempo)} d√≠as`]);
      // Ratio Abiertos/Cerrados
      if (Number(ratio) <= 1.0) items.push(['Ratio Abiertos/Cerrados', 'üü¢ VERDE', `Saludable: ${ratio}`]);
      else if (Number(ratio) <= 1.5) items.push(['Ratio Abiertos/Cerrados', 'üü° AMARILLO', `Atenci√≥n: ${ratio}`]);
      else items.push(['Ratio Abiertos/Cerrados', 'üî¥ ROJO', `Cr√≠tico: ${ratio}`]);
      // Calidad de Datos
      if (totals.vacios === 0) items.push(['Calidad de Datos', 'üü¢ VERDE', 'Excelente calidad']);
      else if (totals.vacios <= 10) items.push(['Calidad de Datos', 'üü° AMARILLO', 'Buena calidad']);
      else items.push(['Calidad de Datos', 'üî¥ ROJO', 'Deficiente calidad']);

      return items;
    }

    function calcularScore(totals, tasaResolucion, promedioTiempo, ratio) {
      let score = 0;
      const maxScore = 100;

      // Tasa de Resoluci√≥n (30 puntos)
      if (Number(tasaResolucion) >= 70) score += 30;
      else if (Number(tasaResolucion) >= 50) score += 20;
      else score += 10;

      // Tiempo Promedio (25 puntos)
      if (promedioTiempo <= 30) score += 25;
      else if (promedioTiempo <= 60) score += 15;
      else score += 5;

      // Ratio Abiertos/Cerrados (25 puntos)
      if (Number(ratio) <= 1.0) score += 25;
      else if (Number(ratio) <= 1.5) score += 15;
      else score += 5;

      // Calidad de Datos (20 puntos)
      if (totals.vacios === 0) score += 20;
      else if (totals.vacios <= 10) score += 10;
      else score += 5;

      const recommendations = [];
      if (Number(tasaResolucion) < 70) recommendations.push('Mejorar la tasa de resoluci√≥n de incidentes.');
      if (promedioTiempo > 30) recommendations.push('Reducir el tiempo promedio de resoluci√≥n.');
      if (Number(ratio) > 1.0) recommendations.push('Optimizar el ratio de abiertos a cerrados.');
      if (totals.vacios > 0) recommendations.push('Incrementar la calidad de los datos.');

      return [
        ['Score Total', `${score} / ${maxScore} puntos`],
        [''],
        ['Recomendaciones para Mejorar el Score:'],
        ...recommendations.map(rec => [`‚Ä¢ ${rec}`])
      ];
    }

    function showLoadingIndicator(message = 'Por favor espere') {
      let overlay = document.getElementById('loadingOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'loadingOverlay';
        overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5);
      display: flex; justify-content: center; align-items: center; z-index: 9999; flex-direction: column;
      font-family: Arial, sans-serif; color: white;
    `;
        overlay.innerHTML = `
      <div style="background: #1f2937; padding: 24px 32px; border-radius: 16px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <div style="margin-bottom: 16px;">
          <div style="width: 48px; height: 48px; border: 6px solid #3b82f6; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        </div>
        <div style="font-size: 18px; font-weight: 600;">${message}</div>
      </div>
      <style>
        @keyframes spin {
          from { transform: rotate(0deg); }
          to   { transform: rotate(360deg); }
        }
      
  /* === ESTILOS GITHUB SYNC === */

  /* Panel de admin - oculto por defecto */
  .github-config-panel {
    display: none;
  }
  .github-config-panel.admin-mode {
    display: block;
  }

  .github-config-panel {
    background: linear-gradient(135deg, #e6e6fa 0%, #f0e6ff 100%);
    border: 2px solid #9370db;
    border-radius: 12px;
    padding: 25px;
    margin: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  .github-config-panel h2 {
    font-size: 20px;
    color: #333;
    margin: 0 0 15px 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .github-config-panel h2::before {
    content: "üîó";
  }
  .github-status {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: #90ee90;
    color: #2d5016;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 500;
  }
  .github-status::before {
    content: "‚úì";
  }
  .github-form {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin-top: 15px;
  }
  .form-group {
    display: flex;
    flex-direction: column;
  }
  .form-group label {
    font-size: 13px;
    font-weight: 600;
    color: #555;
    margin-bottom: 5px;
  }
  .form-group input {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 14px;
    font-family: "Courier New", monospace;
  }
  .form-group input:focus {
    outline: none;
    border-color: #9370db;
    box-shadow: 0 0 0 3px rgba(147, 112, 219, 0.1);
  }
  .form-group input[type="password"] {
    letter-spacing: 3px;
  }
  .github-actions {
    grid-column: 1 / -1;
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }
  .github-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  .github-btn-primary {
    background: #5b9bd5;
    color: white;
  }
  .github-btn-primary:hover {
    background: #4a8ac4;
    transform: translateY(-2px);
  }
  .github-info {
    grid-column: 1 / -1;
    margin-top: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 8px;
    font-size: 13px;
    color: #666;
  }
  .github-info-item {
    display: flex;
    align-items: center;
    gap: 5px;
    margin: 5px 0;
  }
  .github-info-item::before {
    content: "üí°";
  }
  .info-highlight {
    color: #9370db;
    font-weight: 600;
  }
  .auto-load-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background: #4caf50;
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    display: none;
    align-items: center;
    gap: 10px;
    z-index: 1000;
  }
  .auto-load-indicator.show {
    display: flex;
  }
  .loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  @media (max-width: 1024px) {
    .github-form {
      grid-template-columns: 1fr;
    }
  }

</style>
    `;
        document.body.appendChild(overlay);
      }
    }

    function hideLoadingIndicator() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) {
        overlay.remove();
      }
    }

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.style.cssText = `
    position: fixed; bottom: 24px; right: 24px; background: ${type === 'success' ? '#16a34a' : '#dc2626'}; color: white; padding: 16px 24px; border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-family: Arial, sans-serif; display: flex; align-items: center; gap: 12px; animation: slideIn 0.3s ease-out forwards;
    z-index: 10000;
  `;
      const icon = type === 'success' ? '‚úÖ' : '‚ùå';
      notification.innerHTML = `
    <div style="font-size: 20px;">${icon}</div>
    <div style="font-size: 16px;">${message}</div>
  `;
      const style = document.createElement('style');
      style.innerHTML = `
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
  `;
      document.head.appendChild(style);
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        notification.addEventListener('animationend', () => {
          notification.remove();
          style.remove();
        });
      }, 4000);
    }

    function parseNumber(value) {
      if (typeof value === 'number') return value;
      if (typeof value === 'string') {
        const num = parseFloat(value.replace(/[^0-9.-]+/g, ''));
        return isNaN(num) ? NaN : num;
      }
      return NaN;
    }

    function cleanText(text) {
      if (typeof text !== 'string') return text;
      return text.replace(/[\n\r\t]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function average(arr) {
      if (arr.length === 0) return 0;
      return arr.reduce((sum, val) => sum + val, 0) / arr.length;
    }

    function median(arr) {
      if (arr.length === 0) return 0;
      const sorted = arr.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      } else {
        return sorted[mid];
      }
    }

    function getOpenClosedByResponsible(data, colResp, colEstado) {
      const respMap = {};
      data.forEach(r => {
        const resp = r[colResp] ? String(r[colResp]).trim() : 'Sin Responsable';
        const estado = r[colEstado] ? String(r[colEstado]).trim().toLowerCase() : '';
        if (!respMap[resp]) {
          respMap[resp] = { abiertos: 0, cerrados: 0 };
        }
        if (estado === 'abierto' || estado === 'open') {
          respMap[resp].abiertos += 1;
        } else if (estado === 'cerrado' || estado === 'closed') {
          respMap[resp].cerrados += 1;
        }
      });
      return Object.entries(respMap).map(([label, counts]) => ({ label, ...counts }));
    }
    function getOpenClosedByProvider(data, colProv, colEstado) {
      const provMap = {};
      data.forEach(r => {
        const prov = r[colProv] ? String(r[colProv]).trim() : 'Sin Proveedor';
        const estado = r[colEstado] ? String(r[colEstado]).trim().toLowerCase() : '';
        if (!provMap[prov]) {
          provMap[prov] = { abiertos: 0, cerrados: 0 };
        }
        if (estado === 'abierto' || estado === 'open') {
          provMap[prov].abiertos += 1;
        } else if (estado === 'cerrado' || estado === 'closed') {
          provMap[prov].cerrados += 1;
        }
      });
      return Object.entries(provMap).map(([label, counts]) => ({ label, ...counts }));
    }

    function buildOverallSummarySheet(totals) {
      return [
        ['RESUMEN GENERAL DEL BACKLOG DE INCIDENTES'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√âTRICAS PRINCIPALES', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√©trica', 'Valor', 'An√°lisis y Recomendaci√≥n'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Total de Incidentes Analizados', totals.total, ''],
        ['Incidentes Abiertos', totals.abiertos,
          totals.abiertos > totals.cerrados ? 'Alto volumen de abiertos - Priorizar cierre' : 'Volumen de abiertos bajo control'],
        ['Incidentes Cerrados', totals.cerrados,
          totals.cerrados >= totals.abiertos ? 'Buen ritmo de cierre' : 'Mejorar ritmo de cierre'],
        ['Incidentes Devueltos', totals.devuelto,
          totals.devuelto > 15 ? 'Elevado n√∫mero de devueltos - Revisar calidad' : 'Nivel de devueltos aceptable'],
        ['Registros Vac√≠os', totals.vacios,
          totals.vacios > 10 ? 'Muchos registros vac√≠os - Corregir datos' : 'Calidad de datos adecuada'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['AN√ÅLISIS DETALLADO Y ALERTAS', '', ''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['Estado', 'Cantidad', '% del Total', 'Descripci√≥n', 'Acci√≥n Recomendada'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Abiertos', totals.abiertos, `${((totals.abiertos / totals.total) * 100).toFixed(2)}%`, 'Incidentes pendientes de resoluci√≥n',
          totals.abiertos > totals.cerrados ? 'Priorizar cierre' : 'Bajo control'],
        ['Cerrados', totals.cerrados, `${((totals.cerrados / totals.total) * 100).toFixed(2)}%`, 'Incidentes resueltos',
          totals.cerrados >= totals.abiertos ? 'Buen ritmo de cierre' : 'Mejorar ritmo de cierre'],
        ['Devueltos', totals.devuelto, `${((totals.devuelto / totals.total) * 100).toFixed(2)}%`, 'Incidentes retornados por calidad',
          totals.devuelto > 15 ? 'Revisar calidad' : 'Nivel aceptable'],
        ['Registros Vac√≠os', totals.vacios, `${((totals.vacios / totals.total) * 100).toFixed(2)}%`, 'Registros con datos incompletos',
          totals.vacios > 10 ? 'Corregir datos' : 'Calidad adecuada'],
        ['']
      ];
    };

    function buildStateSummarySheet(totals) {
      const stateData = [
        ['RESUMEN DEL ESTADO DEL BACKLOG DE INCIDENTES'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√âTRICAS PRINCIPALES'],
        [''],
        ['Total de Incidentes Analizados:', totals.total],
        ['Incidentes Abiertos:', totals.abiertos],
        ['Incidentes Cerrados:', totals.cerrados],
        ['Incidentes Devueltos:', totals.devuelto],
        ['Registros Vac√≠os:', totals.vacios],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['AN√ÅLISIS Y RECOMENDACIONES'],
        [''],
        totals.abiertos > totals.cerrados ? [`‚ö† Alto volumen de incidentes abiertos (${totals.abiertos}) - Priorizar cierre`] : ['‚úì Volumen de abiertos bajo control'],
        totals.cerrados >= totals.abiertos ? ['‚úì Buen ritmo de cierre de incidentes'] : [`‚ö† Mejorar ritmo de cierre - Cerrados (${totals.cerrados})`],
        totals.devuelto > 15 ? [`‚ö† Elevado n√∫mero de incidentes devueltos (${totals.devuelto}) - Revisar calidad`] : ['‚úì Nivel de devueltos aceptable'],
        totals.vacios > 10 ? [`‚ö† Muchos registros vac√≠os (${totals.vacios}) - Corregir datos`] : ['‚úì Calidad de datos adecuada'],
        ['']
      ];

      const ws = XLSX.utils.aoa_to_sheet(stateData);
      ws['!cols'] = [{ wch: 50 }, { wch: 50 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 1 } },
        { s: { r: 3, c: 0 }, e: { r: 3, c: 1 } },
        { s: { r: 12, c: 0 }, e: { r: 12, c: 1 } },
      ];
      return ws;
    }

    function buildResponsibleAnalysisSheet(colResp, colEstado) {
      const rowsResp = getOpenClosedByResponsible(rawData, colResp, colEstado);
      const data = [['AN√ÅLISIS POR RESPONSABLE'], [''], ['Responsable', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'Eficiencia', 'Estado', 'Acci√≥n Recomendada']];

      rowsResp.forEach(r => {
        const total = r.abiertos + r.cerrados;
        const eficiencia = ((r.cerrados / total) * 100).toFixed(1);
        const estado = Number(eficiencia) < 50 ? '‚ùå Cr√≠tico' : Number(eficiencia) < 70 ? '‚ö† Medio' : '‚úì Bueno';
        const accion = Number(eficiencia) < 50 ? 'Mejorar gesti√≥n' : Number(eficiencia) < 70 ? 'Monitorear desempe√±o' : 'Mantener seguimiento';
        data.push([cleanText(r.label), r.abiertos, `${((r.abiertos / total) * 100).toFixed(1)}%`, r.cerrados, `${((r.cerrados / total) * 100).toFixed(1)}%`, total, `${eficiencia}%`, estado, accion]);
      });

      const totalAbiertos = rowsResp.reduce((sum, r) => sum + r.abiertos, 0);
      const totalCerrados = rowsResp.reduce((sum, r) => sum + r.cerrados, 0);
      const totalGeneral = totalAbiertos + totalCerrados;
      data.push(['']);
      data.push(['TOTAL', totalAbiertos, `${((totalAbiertos / totalGeneral) * 100).toFixed(1)}%`, totalCerrados, `${((totalCerrados / totalGeneral) * 100).toFixed(1)}%`, totalGeneral, '', '', '']);
      data.push(['']);
      data.push(['RESUMEN Y DESTACADOS']);
      data.push(['']);
      data.push(['Responsable con m√°s casos:', rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.label || 'N/A',
        (rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.abiertos + rowsResp.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.cerrados) || 0]);
      data.push(['Responsable con mejor eficiencia:', rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0]?.label || 'N/A',
        `${rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0] ? ((rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados / (rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].abiertos + rowsResp.slice().sort((a, b) => ((b.cerrados / (b.abiertos + b.cerrados)) - (a.cerrados / (a.abiertos + a.cerrados))))[0].cerrados)) * 100).toFixed(1) : '0'}%`]);
      data.push(['']);

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 25 }];
      return ws;
    }

    function buildServiceAnalysisSheet(colServicio) {
      if (!colServicio) return XLSX.utils.aoa_to_sheet([['No hay datos de servicio disponibles']]);

      const serviceCounts = {};
      rawData.forEach(r => {
        const servicio = r[colServicio] ? String(r[colServicio]).trim() : 'Sin Servicio';
        serviceCounts[servicio] = (serviceCounts[servicio] || 0) + 1;
      });

      const counts = Object.entries(serviceCounts).map(([label, value]) => ({ label, value }));
      const total = counts.reduce((sum, s) => sum + s.value, 0);
      const data = [['AN√ÅLISIS POR SERVICIO'], [''], ['Servicio', 'Recomendaci√≥n']];

      counts.forEach(s => {
        const porcentaje = (s.value / total) * 100;
        let recomendacion = '';
        if (porcentaje > 30) recomendacion = '‚ùå Alto volumen - Priorizar revisi√≥n';
        else if (porcentaje > 15) recomendacion = '‚ö† Medio volumen - Monitorear desempe√±o';
        else recomendacion = '‚úì Bajo volumen - Mantener seguimiento';
        data.push([cleanText(s.label), recomendacion]);
      });
      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 50 }, { wch: 40 }];
      return ws;
    }

    function buildTimeAnalysisSheet(colTiempo) {
      const tiempos = rawData.map(r => parseNumber(r[colTiempo])).filter(n => !isNaN(n));
      if (tiempos.length === 0) return XLSX.utils.aoa_to_sheet([['No hay datos de tiempo disponibles']]);

      const promedio = average(tiempos);
      const max = Math.max(...tiempos);
      const min = Math.min(...tiempos);
      const mediana = median(tiempos);

      const rangos = [
        { label: '0-1 d√≠a', min: 0, max: 1, count: 0 },
        { label: '2-5 d√≠as', min: 2, max: 5, count: 0 },
        { label: '6-15 d√≠as', min: 6, max: 15, count: 0 },
        { label: '16-30 d√≠as', min: 16, max: 30, count: 0 },
        { label: '31-60 d√≠as', min: 31, max: 60, count: 0 },
        { label: '61-90 d√≠as', min: 61, max: 90, count: 0 },
        { label: '91+ d√≠as', min: 91, max: Infinity, count: 0 },
      ];

      tiempos.forEach(t => {
        for (const rango of rangos) {
          if (t >= rango.min && t <= rango.max) {
            rango.count += 1;
            break;
          }
        }
      });

      tiempos.forEach(t => {
        for (const rango of rangos) {
          if (t >= rango.min && t <= rango.max) {
            rango.count += 1;
            break;
          }
        }
      });

      const data = [
        ['AN√ÅLISIS DE TIEMPOS DE RESOLUCI√ìN DE INCIDENTES'],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['M√âTRICAS DE TIEMPO DE RESOLUCI√ìN'],
        [''],
        ['Tiempo Promedio de Resoluci√≥n', `${Math.round(promedio)} d√≠as`],
        ['Tiempo M√°ximo de Resoluci√≥n', `${max} d√≠as`],
        ['Tiempo M√≠nimo de Resoluci√≥n', `${min} d√≠as`],
        ['Tiempo Mediano de Resoluci√≥n', `${mediana} d√≠as`],
        [''],
        ['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'],
        ['DISTRIBUCI√ìN DE TIEMPOS DE RESOLUCI√ìN'],
        ['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'],
        ['Rango de D√≠as', 'Cantidad de Incidentes', '% del Total', 'Nivel de Atenci√≥n Recomendado'],
        ...rangos.map(r => [r.label, r.count, `${((r.count / tiempos.length) * 100).toFixed(2)}%`,
        r.count / tiempos.length > 0.3 ? '‚ùå Alto - Priorizar' : r.count / tiempos.length > 0.15 ? '‚ö† Medio - Monitorear' : '‚úì Bajo - Mantener']),
        ['']
      ];

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws['!cols'] = [{ wch: 25 }, { wch: 25 }, { wch: 15 }, { wch: 30 }];
      ws['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 3 } },
        { s: { r: 3, c: 0 }, e: { r: 3, c: 3 } },
        { s: { r: 11, c: 0 }, e: { r: 11, c: 3 } },
        { s: { r: 13, c: 0 }, e: { r: 13, c: 3 } },
        { s: { r: 9, c: 0 }, e: { r: 9, c: 3 } },
      ];
      return ws;
    }

    function buildProviderAnalysisSheet(colProv, colEstado) {
      const rowsProv = getOpenClosedByProvider(rawData, colProv, colEstado);
      const data = [['AN√ÅLISIS POR PROVEEDOR'], [''], ['Proveedor', 'Abiertos', '% Abiertos', 'Cerrados', '% Cerrados', 'Total', 'SLA', 'Criticidad']];

      rowsProv.forEach(p => {
        const total = p.abiertos + p.cerrados;
        const sla = total === 0 ? 0 : ((p.cerrados / total) * 100).toFixed(1);
        let criticidad = '';
        if (sla < 50) criticidad = '‚ùå Cr√≠tico';
        else if (sla < 70) criticidad = '‚ö† Medio';
        else criticidad = '‚úì Bueno';
        data.push([cleanText(p.label), p.abiertos, `${((p.abiertos / total) * 100).toFixed(1)}%`, p.cerrados, `${((p.cerrados / total) * 100).toFixed(1)}%`, total, `${sla}%`, criticidad]);
      });

      const totalAbiertos = rowsProv.reduce((sum, p) => sum + p.abiertos, 0);
      const totalCerrados = rowsProv.reduce((sum, p) => sum + p.cerrados, 0);
      const totalGeneral = totalAbiertos + totalCerrados;
      data.push(['']);
      data.push(['TOTAL', totalAbiertos, `${((totalAbiertos / totalGeneral) * 100).toFixed(1)}%`, totalCerrados, `${((totalCerrados / totalGeneral) * 100).toFixed(1)}%`, totalGeneral, '', '']);
      data.push(['']);
      data.push(['RESUMEN Y DESTACADOS']);
      data.push(['']);
      data.push(['Proveedor con m√°s casos:', rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.label || 'N/A',
        (rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.abiertos + rowsProv.slice().sort((a, b) => (b.abiertos + b.cerrados) - (a.abiertos + a.cerrados))[0]?.cerrados) || 0]);
      data.push(['Proveedor con m√°s casos cerrados:', rowsProv.slice().sort((a, b) => b.cerrados - a.cerrados)[0]?.label || 'N/A',
        (rowsProv.slice().sort((a, b) => b.cerrados - a.cerrados)[0]?.cerrados) || 0]);
      data.pu
      data.push(["Proveedor con menor SLA:", rowsProv.slice().sort((a, b) => ((a.cerrados / (a.abiertos + a.cerrados)) - (b.cerrados / (b.abiertos + b.cerrados))))[0]?.label || "N/A",
        rowsProv.slice().sort((a, b) => ((a.cerrados / (a.abiertos + a.cerrados)) - (b.cerrados / (b.abiertos + b.cerrados))))[0] ? 
        `${((rowsProv.slice().sort((a, b) => ((a.cerrados / (a.abiertos + a.cerrados)) - (b.cerrados / (b.abiertos + b.cerrados))))[0].cerrados / 
        (rowsProv.slice().sort((a, b) => ((a.cerrados / (a.abiertos + a.cerrados)) - (b.cerrados / (b.abiertos + b.cerrados))))[0].abiertos + 
        rowsProv.slice().sort((a, b) => ((a.cerrados / (a.abiertos + a.cerrados)) - (b.cerrados / (b.abiertos + b.cerrados))))[0].cerrados)) * 100).toFixed(1)}%` : "0%"]);
      data.push([""]);

      const ws = XLSX.utils.aoa_to_sheet(data);
      ws["!cols"] = [{ wch: 35 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 20 }];
      return ws;
    }

    // ================== Exponer funciones necesarias ==================
    
    // ==========================================
    // CONFIGURACI√ìN Y FUNCIONES DE GITHUB
    // ==========================================
    
    const GITHUB_CONFIG_KEY = 'github_config_dashboard_v2';
    const CSV_FILENAME = 'EST_VPT_BackLog_Incidentes_BU_V001_20250812(Backlog Incidentes TI).csv';
    
    function loadGithubConfig() {
      const saved = localStorage.getItem(GITHUB_CONFIG_KEY);
      if (saved) {
        try {
          const config = JSON.parse(saved);
          if(document.getElementById('githubUser')) document.getElementById('githubUser').value = config.user || '';
          if(document.getElementById('githubRepo')) document.getElementById('githubRepo').value = config.repo || '';
          if(document.getElementById('githubBranch')) document.getElementById('githubBranch').value = config.branch || 'main';
          if(document.getElementById('githubToken')) document.getElementById('githubToken').value = config.token || '';
          
          if (config.user && config.repo) {
            const statusEl = document.getElementById('githubStatus');
            if(statusEl) {
              statusEl.textContent = `Admin (${config.user}/${config.repo})`;
              statusEl.style.display = 'inline-flex';
            }
          }
          return config;
        } catch (e) {
          console.error('Error cargando configuraci√≥n:', e);
        }
      }
      return null;
    }
    
    function saveGithubConfig() {
      const config = {
        user: document.getElementById('githubUser').value.trim(),
        repo: document.getElementById('githubRepo').value.trim(),
        branch: document.getElementById('githubBranch').value.trim() || 'main',
        token: document.getElementById('githubToken').value.trim()
      };
      
      if (!config.user || !config.repo) {
        alert('Por favor completa Usuario y Repositorio');
        return false;
      }
      
      localStorage.setItem(GITHUB_CONFIG_KEY, JSON.stringify(config));
      
      const statusEl = document.getElementById('githubStatus');
      if(statusEl) {
        statusEl.textContent = `Admin (${config.user}/${config.repo})`;
        statusEl.style.display = 'inline-flex';
      }
      
      // Generar URLs para compartir
      const baseUrl = window.location.origin + window.location.pathname;
      const adminUrl = baseUrl + '?admin=1';
      const userUrl = baseUrl;
      
      alert(`‚úÖ Configuraci√≥n guardada correctamente!

üìã URLS PARA COMPARTIR:

üîê ADMIN (solo para ti):
${adminUrl}

üë• USUARIOS (sin configuraci√≥n):
${userUrl}

üí° Los usuarios normales ver√°n autom√°ticamente los datos desde GitHub sin necesidad de configurar nada.`);
      
      return true;
    }
    
    async function testGithubConnection() {
      const config = {
        user: document.getElementById('githubUser').value.trim(),
        repo: document.getElementById('githubRepo').value.trim(),
        token: document.getElementById('githubToken').value.trim()
      };
      
      if (!config.user || !config.repo) {
        alert('Por favor completa Usuario y Repositorio');
        return;
      }
      
      showAutoLoadIndicator('Probando conexi√≥n con GitHub...');
      
      try {
        const url = `https://api.github.com/repos/${config.user}/${config.repo}`;
        const headers = {};
        if (config.token) headers['Authorization'] = `token ${config.token}`;
        
        const response = await fetch(url, { headers });
        
        if (response.ok) {
          const data = await response.json();
          hideAutoLoadIndicator();
          alert(`‚úÖ Conexi√≥n exitosa!\n\nRepositorio: ${data.full_name}\nRama: ${data.default_branch}\nVisibilidad: ${data.private ? 'Privado' : 'P√∫blico'}`);
        } else {
          hideAutoLoadIndicator();
          alert(`‚ùå Error (${response.status})\n\nVerifica:\n- Usuario y repositorio correctos\n- Token tiene permisos "repo"`);
        }
      } catch (error) {
        hideAutoLoadIndicator();
        alert(`‚ùå Error: ${error.message}`);
      }
    }
    

    // ==========================================
    // SUBIR ARCHIVO CSV A GITHUB AUTOM√ÅTICAMENTE
    // ==========================================
    
    async function uploadCSVToGithub(csvContent, filename) {
      const config = loadGithubConfig();
      
      if (!config || !config.token) {
        console.error('No hay token de GitHub configurado');
        alert('‚ö†Ô∏è No se puede subir a GitHub. Configura el token primero.');
        return false;
      }
      
      showAutoLoadIndicator('Subiendo archivo a GitHub...');
      
      try {
        // Primero verificar si el archivo existe
        const checkUrl = `https://api.github.com/repos/${config.user}/${config.repo}/contents/${filename}`;
        const checkHeaders = {
          'Authorization': `token ${config.token}`,
          'Accept': 'application/vnd.github.v3+json'
        };
        
        let sha = null;
        try {
          const checkResponse = await fetch(checkUrl, { headers: checkHeaders });
          if (checkResponse.ok) {
            const data = await checkResponse.json();
            sha = data.sha;
            console.log('Archivo existente encontrado, se actualizar√°');
          }
        } catch (e) {
          console.log('Archivo no existe, se crear√° nuevo');
        }
        
        // Convertir contenido a base64
        const base64Content = btoa(unescape(encodeURIComponent(csvContent)));
        
        // Preparar datos para GitHub API
        const payload = {
          message: `Actualizaci√≥n autom√°tica de datos - ${new Date().toLocaleString('es-ES')}`,
          content: base64Content,
          branch: config.branch || 'main'
        };
        
        if (sha) {
          payload.sha = sha; // Necesario para actualizar archivo existente
        }
        
        // Subir archivo
        const uploadUrl = `https://api.github.com/repos/${config.user}/${config.repo}/contents/${filename}`;
        const uploadHeaders = {
          'Authorization': `token ${config.token}`,
          'Content-Type': 'application/json',
          'Accept': 'application/vnd.github.v3+json'
        };
        
        const response = await fetch(uploadUrl, {
          method: 'PUT',
          headers: uploadHeaders,
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          hideAutoLoadIndicator();
          
          // Actualizar banner
          const bannerSource = document.getElementById('bannerSource');
          if(bannerSource) {
            bannerSource.textContent = 'GitHub (Sincronizado)';
            bannerSource.style.background = '#4caf50';
          }
          
          alert('‚úÖ Archivo subido a GitHub exitosamente!\n\nüë• Todos los usuarios ver√°n estos datos actualizados.');
          console.log('‚úÖ CSV subido a GitHub');
          return true;
        } else {
          const errorData = await response.json();
          hideAutoLoadIndicator();
          console.error('Error subiendo a GitHub:', errorData);
          alert(`‚ùå Error al subir a GitHub (${response.status})\n\n${errorData.message || 'Error desconocido'}\n\nVerifica que el token tenga permisos de escritura.`);
          return false;
        }
      } catch (error) {
        hideAutoLoadIndicator();
        console.error('Error:', error);
        alert(`‚ùå Error al subir a GitHub: ${error.message}`);
        return false;
      }
    }
    
    // Variable global para almacenar el contenido CSV actual
    window.currentCSVContent = null;
    
    async function loadCSVFromGithub() {
      const config = loadGithubConfig();
      
      if (!config || !config.user || !config.repo) {
        console.log('No hay configuraci√≥n de GitHub');
        return null;
      }
      
      showAutoLoadIndicator('Cargando datos desde GitHub...');
      
      try {
        const url = `https://raw.githubusercontent.com/${config.user}/${config.repo}/${config.branch}/${CSV_FILENAME}`;
        console.log('Cargando desde:', url);
        
        const headers = {};
        if (config.token) headers['Authorization'] = `token ${config.token}`;
        
        const response = await fetch(url, { headers, cache: 'no-cache' });
        
        if (response.ok) {
          const csvText = await response.text();
          hideAutoLoadIndicator();
          
          const bannerSource = document.getElementById('bannerSource');
          if(bannerSource) {
            bannerSource.textContent = 'GitHub';
            bannerSource.style.background = '#4caf50';
          }
          
          console.log('‚úÖ CSV cargado desde GitHub');
          return csvText;
        } else {
          hideAutoLoadIndicator();
          console.error('Error cargando CSV:', response.status);
          if (response.status === 404) {
            alert(`‚ö†Ô∏è Archivo no encontrado\n\nAseg√∫rate de que "${CSV_FILENAME}" est√© en el repositorio`);
          }
          return null;
        }
      } catch (error) {
        hideAutoLoadIndicator();
        console.error('Error:', error);
        return null;
      }
    }
    
    function showAutoLoadIndicator(message) {
      const indicator = document.getElementById('autoLoadIndicator');
      const messageEl = document.getElementById('autoLoadMessage');
      if(indicator && messageEl) {
        messageEl.textContent = message;
        indicator.classList.add('show');
      }
    }
    
    function hideAutoLoadIndicator() {
      const indicator = document.getElementById('autoLoadIndicator');
      if(indicator) {
        setTimeout(() => indicator.classList.remove('show'), 1000);
      }
    }
    

    function copyUrlsToClipboard() {
      const config = loadGithubConfig();
      if (!config || !config.user || !config.repo) {
        alert('‚ö†Ô∏è Primero guarda la configuraci√≥n');
        return;
      }
      
      const baseUrl = window.location.origin + window.location.pathname;
      const adminUrl = baseUrl + '?admin=1';
      const userUrl = baseUrl;
      
      const text = `URLS DEL DASHBOARD DE INCIDENTES TI

üîê URL ADMINISTRADOR (solo para ti):
${adminUrl}

üë• URL USUARIOS (compartir con el equipo):
${userUrl}

üí° Los usuarios ver√°n autom√°ticamente los datos actualizados desde GitHub.`;
      
      navigator.clipboard.writeText(text).then(() => {
        alert('‚úÖ URLs copiadas al portapapeles!');
      }).catch(() => {
        prompt('üìã Copia estas URLs:', text);
      });
    }
    
    // Inicializaci√≥n
    setTimeout(function() {
      const btnTest = document.getElementById('btnTestConnection');
      const btnSave = document.getElementById('btnSaveConfig');
      
      if(btnTest) btnTest.addEventListener('click', testGithubConnection);
      if(btnSave) btnSave.addEventListener('click', saveGithubConfig);
      
      const btnCopyUrls = document.getElementById('btnCopyUrls');
      if(btnCopyUrls) btnCopyUrls.addEventListener('click', copyUrlsToClipboard);
      
      loadGithubConfig();

      // Mostrar bot√≥n de subir a GitHub solo para admin si hay datos cargados
      const btnUploadToGithub = document.getElementById('btnUploadToGithub');
      if (btnUploadToGithub && isAdminMode()) {
        btnUploadToGithub.style.display = 'inline-block';
        btnUploadToGithub.addEventListener('click', async function() {
          if (!window.currentCSVContent) {
            alert('‚ö†Ô∏è Primero carga un archivo CSV');
            return;
          }
          
          const shouldUpload = confirm('üì§ ¬øSubir el archivo actual a GitHub?\n\nTodos los usuarios ver√°n estos datos.');
          if (shouldUpload) {
            await uploadCSVToGithub(window.currentCSVContent, CSV_FILENAME);
          }
        });
      }
      
      // Intentar cargar CSV desde GitHub autom√°ticamente
      setTimeout(async function() {
        const csvText = await loadCSVFromGithub();
        if (csvText && typeof handleFile === 'function') {
          const fakeEvent = {
            target: {
              files: [new Blob([csvText], { type: 'text/csv' })]
            }
          };
          fakeEvent.target.files[0].name = CSV_FILENAME;
          const reader = new FileReader();
          reader.onload = function(e) {
            if(window.Papa && window.Papa.parse) {
              const result = window.Papa.parse(e.target.result, {
                header: true,
                skipEmptyLines: true,
                encoding: 'UTF-8'
              });
              if(result && result.data) {
                // Guardar contenido CSV para subir a GitHub
                window.currentCSVContent = e.target.result;
                
                // Procesar datos
                handleParsedData(result.data, CSV_FILENAME);
                
                // Si es admin, ofrecer subir a GitHub
                if (isAdminMode()) {
                  setTimeout(async function() {
                    const shouldUpload = confirm('üì§ ¬øDeseas subir este archivo a GitHub para que todos los usuarios lo vean?\n\n‚úÖ S√ç: Todos ver√°n estos datos\n‚ùå NO: Solo t√∫ lo ver√°s localmente');
                    
                    if (shouldUpload) {
                      const uploaded = await uploadCSVToGithub(window.currentCSVContent, CSV_FILENAME);
                      if (!uploaded) {
                        console.log('No se pudo subir a GitHub, los datos solo est√°n disponibles localmente');
                      }
                    }
                  }, 500);
                }
              }
            }
          };
          reader.readAsText(fakeEvent.target.files[0], 'UTF-8');
        }
      }, 500);
    }, 100);
    

    // Exponer funci√≥n
    window.handleCSVData = handleFile;
  </script>

  </body>
  </html>
